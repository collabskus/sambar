
===============================================================================
ASP.NET PROJECT EXPORT
Generated: 09/25/2025 15:08:19
Project Path: D:\DEV\sambar
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing for volume DATA
Volume serial number is 128B-05C1
D:\DEV\SAMBAR
|   .gitignore
|   LICENSE
|   README.md
|   
+---Docs
|   |   Api.md
|   |   Basics.md
|   |   Configuration.md
|   |   Landing.md
|   |   project_export.txt
|   |   
|   +---Showcase
|   |       Landing.md
|   |       
|   \---Tutorials
|           Landing.md
|           Layout.md
|           Widgets.md
|           
+---Imgs
|       explorer_fi1Oz9MPqd.gif
|       Screenshot 2025-07-14 182909.png
|       
+---Scripts
|       createRelease.ps1
|       Get-Contents.ps1
|       
+---Src
|   |   AssemblyInfo.cs
|   |   Main.cs
|   |   sambar.csproj
|   |   
|   +---Classes
|   |   |   Sambar.cs
|   |   |   
|   |   +---Api
|   |   |       Api.cs
|   |   |       Audio.cs
|   |   |       Clocks.cs
|   |   |       Counters.cs
|   |   |       CustomWindows.cs
|   |   |       Events.cs
|   |   |       GlazeWM.cs
|   |   |       LaunchApps.cs
|   |   |       Menus.cs
|   |   |       System.cs
|   |   |       SystemTray.cs
|   |   |       Taskbar.cs
|   |   |       ToggleTaskbar.cs
|   |   |       Utilities.cs
|   |   |       WindowCatcher.cs
|   |   |       WindowTracker.cs
|   |   |       
|   |   +---Com
|   |   |       CLSID.cs
|   |   |       Enums.cs
|   |   |       Interfaces.cs
|   |   |       Structs.cs
|   |   |       
|   |   +---Config
|   |   |       Config.cs
|   |   |       Layout.cs
|   |   |       Paths.cs
|   |   |       
|   |   +---Engine
|   |   |       Widget.cs
|   |   |       WidgetEngine.cs
|   |   |       
|   |   +---Hooks
|   |   |   \---minhook
|   |   |           hooker.cs
|   |   |           hookerInjector.cs
|   |   |           target.cs
|   |   |           
|   |   +---Schemas
|   |   |       GlazeSchemas.cs
|   |   |       
|   |   +---Ui
|   |   |       ItemSelector.cs
|   |   |       RoundedButton.cs
|   |   |       StackPanel.cs
|   |   |       
|   |   +---Utils
|   |   |       Core.cs
|   |   |       Extensions.cs
|   |   |       Logger.cs
|   |   |       
|   |   \---Win32
|   |           Delegates.cs
|   |           Enums.cs
|   |           Functions.cs
|   |           Structs.cs
|   |           
|   +---Properties
|   |       launchSettings.json
|   |       
|   +---Tests
|   |       CTaskListWnd_CreateInstance.cpp
|   |       Interceptor.cs
|   |       main.cpp
|   |       ntquery.c
|   |       QueryPdb.cs
|   |       QueryPdb.runtimeconfig.json
|   |       Taskbar.pdb
|   |       TaskbarWindows.cs
|   |       
|   \---WidgetPacks
|       |   .init.cs
|       |   
|       +---Base
|       |   |   .config.cs
|       |   |   .layout.cs
|       |   |   .theme.cs
|       |   |   AudioInformation.widget.cs
|       |   |   AudioVisualizer.widget.cs
|       |   |   Clock.widget.cs
|       |   |   Counters.widget.cs
|       |   |   HideTaskbar.widget.cs
|       |   |   NetworkManager.widget.cs
|       |   |   ScribblePad.widget.cs
|       |   |   StartButton.widget.cs
|       |   |   TaskbarApps.widget.cs
|       |   |   Tray.widget.cs
|       |   |   Wallpapers.widget.cs
|       |   |   Workspaces.widget.cs
|       |   |   
|       |   \---assets
|       |           arrow_down.svg
|       |           image.svg
|       |           start.svg
|       |           wifi.svg
|       |           
|       \---Plain1
|               .config.cs
|               .imports.cs
|               .layout.cs
|               .theme.cs
|               
\---Todo
        Bugs.md
        


FILE CONTENTS:
==============

================================================================================
FILE: :\DEV\sambar\Docs\Api.md
SIZE: 0.58 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Api Reference

The entire Sambar api exists as a single partial class thats made available to plugins as an instance of this class.
When Sambar initializes this instance is set to the variable `Sambar.api`. The Api class is spread out in all the files 
in the [Api folder](https://github.com/TheAjaykrishnanR/sambar/tree/master/Src/Classes/Api). So you can read through all
the public functions and events defined in those files and thats bassically all the functionality exposed through the api.

Much of the Api is served as events that you can subscribe to from your plugins.



================================================================================
FILE: :\DEV\sambar\Docs\Basics.md
SIZE: 2.03 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Basics

## Downloading

Download the latest release from [releases]()

## Launching

Launch the sambar by double clicking the `sambar.exe` executable. If you want to see the live debug output, run the executable from a console such as powershell or cmd.

## Logging

The logfile `sambar.log` can be found alongside the executable which will be created after the first run.

## Exiting

Right clicking anywhere on the bar will open a context menu containing the option to exit.

You can also kill `sambar.exe` from the task manager or by running `taskkill /IM sambar.exe` from cmd/pwsh. Even while running the terminal, since the bar window runs on its own UI thread the `Main()` returns immediately, so `Ctrl-C` wont work to kill sambar.

# Widgets

Widgets are organized into a `Pack`. They are a collection of widgets. You can see them in the `WidgetPacks` folder. `sambar.exe` looks for this folder in the location where the binary is located. A basic set of widgets have been already written for you in the `Base` widget pack. You can include them or copy and modify them to create your own widget packs.

Each widget pack is folder in the `WidgetPacks` folder. To create your own widget pack, first create a folder in `WidgetPacks` and give it the name you want. You will notice that in the `widgetPacks` folder there is a file called `.init.cs`. Sambar will look for this file in order to determine which widgetPack you want to use. So inorder to use the widget pack you have created, change the `return "Base"` in `init.cs` to `return "<YOUR WIDGETPACKNAME>"` where the `WIDGETPACKNAME` is the folder name you specified before.

But your newly created widgetpack is empty. So you need to create some widgets. If your merely want to modify existing widgets, modifying them in `Base` is enough. But if you want to create a new layout or a layout with different colors, its better to create a new widget pack.

To start hacking with sambar have a go at [Tutorials](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials/Landing.md)



================================================================================
FILE: :\DEV\sambar\Docs\Configuration.md
SIZE: 2.81 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Configuration

Code and configuration are the same. Everything configurable in Sambar are present in `.cs` files in the `WidgetPacks` folder. There are no `json` or `yaml` files. At its core sambar exposes an api and is a script runner. With this approach it is possible to customize sambar to its fullest extend. You are not limited to the customization thats exposed by a widget, instead you can customize the widget yourself.

## Directory Structure

```
   WidgetPacks
   â”œâ”€â”€â”€Base
   â”‚   â””â”€â”€â”€assets
   â”‚   .config.cs
   â”‚   .layout.cs
   â”‚   .theme.cs
   â”‚   <-->.widget.cs
   â””â”€â”€â”€Plain1
       .config.cs
       .layout.cs
       .imports.cs
       .theme.cs
   .init.cs
```

A widgetpack is a the fundamental unit composed of a collection of widgets and configuration files necessary for a fully functional bar with a certain style/theme.

Each widget pack contains a set of widgets (ending with `.widget.cs` extensions) and a set of configuration files (or dotfiles): `.config.cs`, `.layout.cs`, `.theme.cs`

The root WidgetPacks folder contains an `.init.cs` file. Sambar will use the widgetpack returned from this file.

Lets have a look at these files in depth: 

#### `.config.cs` : 

Configure the primary properties of the bar window that are necessary during launch, these (and their default values) are:

```cs
int height = 40;
int width = 0;
int marginXLeft = 10;
int marginXRight = 10;
int marginYTop = 10;
int paddingXLeft = 0;
int paddingXRight = 0;
int paddingYTop = 0;
int paddingYDown = 0;
string backgroundColor = "";
bool roundedCorners = true;
string borderColor = "";
int borderThickness = 0;
string widgetPack = "Base";
```

#### `.layout.cs`: 

This file basically defines the layout of all the widgets in the sambar bar. Their positioning, sizes, everything. Refer to [constructing the widgets layout]() for a detailed look into creating or changing the layout of sambar.

#### `.theme.cs`: 

This file contains a static class called `Theme` which can hold global variables for common use by your widgets. Say `TEXT_COLOR` for example and you need a common text color in all your widgetsfor creating a particular theme. Then you can make that as a variable in here. They can be called from the widgets easily as `Theme.TEXT_COLOR`.

#### `.init.cs`:

contains a single return statement

```cs
return "<WIDGETPACKNAME>";
```

#### `.imports.cs`:

Notice in `Plain1` widgetpack there's another file called `.imports.cs`. Well `Plain1` is just a slight modification of the `Base` widgetpack and therefore "imports" the default widgets from `Base` without any modification to the widgets themselves. This is so that you dont have to copy unmodified `.widget.cs` files if all you need is to have them as it is in your new widgetpack/theme.





================================================================================
FILE: :\DEV\sambar\Docs\Landing.md
SIZE: 0.8 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Welcome to sambar docs !

The docs cover everything you need to successfully run, configure and develop plugins for the sambar status bar.
Have a quick rundown through basics to get started with setting up sambar, how to launch the app, read the logs etc.
For more indepth topics such as configuring the widgets or even creating new ones, go through the tutorial. While developing
new plugins the Sambar Api is incredibly useful, see the Api reference here.

 1. [Basics](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Basics.md)
 2. [Configuration](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Configuration.md)
 3. [Tutorials](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials.md)
 4. [Api](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Api.md)



================================================================================
FILE: :\DEV\sambar\Docs\project_export.txt
SIZE: 11.12 KB
MODIFIED: 09/25/2025 15:08:20
================================================================================


===============================================================================
ASP.NET PROJECT EXPORT
Generated: 09/25/2025 15:08:19
Project Path: D:\DEV\sambar
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing for volume DATA
Volume serial number is 128B-05C1
D:\DEV\SAMBAR
|   .gitignore
|   LICENSE
|   README.md
|   
+---Docs
|   |   Api.md
|   |   Basics.md
|   |   Configuration.md
|   |   Landing.md
|   |   project_export.txt
|   |   
|   +---Showcase
|   |       Landing.md
|   |       
|   \---Tutorials
|           Landing.md
|           Layout.md
|           Widgets.md
|           
+---Imgs
|       explorer_fi1Oz9MPqd.gif
|       Screenshot 2025-07-14 182909.png
|       
+---Scripts
|       createRelease.ps1
|       Get-Contents.ps1
|       
+---Src
|   |   AssemblyInfo.cs
|   |   Main.cs
|   |   sambar.csproj
|   |   
|   +---Classes
|   |   |   Sambar.cs
|   |   |   
|   |   +---Api
|   |   |       Api.cs
|   |   |       Audio.cs
|   |   |       Clocks.cs
|   |   |       Counters.cs
|   |   |       CustomWindows.cs
|   |   |       Events.cs
|   |   |       GlazeWM.cs
|   |   |       LaunchApps.cs
|   |   |       Menus.cs
|   |   |       System.cs
|   |   |       SystemTray.cs
|   |   |       Taskbar.cs
|   |   |       ToggleTaskbar.cs
|   |   |       Utilities.cs
|   |   |       WindowCatcher.cs
|   |   |       WindowTracker.cs
|   |   |       
|   |   +---Com
|   |   |       CLSID.cs
|   |   |       Enums.cs
|   |   |       Interfaces.cs
|   |   |       Structs.cs
|   |   |       
|   |   +---Config
|   |   |       Config.cs
|   |   |       Layout.cs
|   |   |       Paths.cs
|   |   |       
|   |   +---Engine
|   |   |       Widget.cs
|   |   |       WidgetEngine.cs
|   |   |       
|   |   +---Hooks
|   |   |   \---minhook
|   |   |           hooker.cs
|   |   |           hookerInjector.cs
|   |   |           target.cs
|   |   |           
|   |   +---Schemas
|   |   |       GlazeSchemas.cs
|   |   |       
|   |   +---Ui
|   |   |       ItemSelector.cs
|   |   |       RoundedButton.cs
|   |   |       StackPanel.cs
|   |   |       
|   |   +---Utils
|   |   |       Core.cs
|   |   |       Extensions.cs
|   |   |       Logger.cs
|   |   |       
|   |   \---Win32
|   |           Delegates.cs
|   |           Enums.cs
|   |           Functions.cs
|   |           Structs.cs
|   |           
|   +---Properties
|   |       launchSettings.json
|   |       
|   +---Tests
|   |       CTaskListWnd_CreateInstance.cpp
|   |       Interceptor.cs
|   |       main.cpp
|   |       ntquery.c
|   |       QueryPdb.cs
|   |       QueryPdb.runtimeconfig.json
|   |       Taskbar.pdb
|   |       TaskbarWindows.cs
|   |       
|   \---WidgetPacks
|       |   .init.cs
|       |   
|       +---Base
|       |   |   .config.cs
|       |   |   .layout.cs
|       |   |   .theme.cs
|       |   |   AudioInformation.widget.cs
|       |   |   AudioVisualizer.widget.cs
|       |   |   Clock.widget.cs
|       |   |   Counters.widget.cs
|       |   |   HideTaskbar.widget.cs
|       |   |   NetworkManager.widget.cs
|       |   |   ScribblePad.widget.cs
|       |   |   StartButton.widget.cs
|       |   |   TaskbarApps.widget.cs
|       |   |   Tray.widget.cs
|       |   |   Wallpapers.widget.cs
|       |   |   Workspaces.widget.cs
|       |   |   
|       |   \---assets
|       |           arrow_down.svg
|       |           image.svg
|       |           start.svg
|       |           wifi.svg
|       |           
|       \---Plain1
|               .config.cs
|               .imports.cs
|               .layout.cs
|               .theme.cs
|               
\---Todo
        Bugs.md
        


FILE CONTENTS:
==============

================================================================================
FILE: :\DEV\sambar\Docs\Api.md
SIZE: 0.58 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Api Reference

The entire Sambar api exists as a single partial class thats made available to plugins as an instance of this class.
When Sambar initializes this instance is set to the variable `Sambar.api`. The Api class is spread out in all the files 
in the [Api folder](https://github.com/TheAjaykrishnanR/sambar/tree/master/Src/Classes/Api). So you can read through all
the public functions and events defined in those files and thats bassically all the functionality exposed through the api.

Much of the Api is served as events that you can subscribe to from your plugins.



================================================================================
FILE: :\DEV\sambar\Docs\Basics.md
SIZE: 2.03 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Basics

## Downloading

Download the latest release from [releases]()

## Launching

Launch the sambar by double clicking the `sambar.exe` executable. If you want to see the live debug output, run the executable from a console such as powershell or cmd.

## Logging

The logfile `sambar.log` can be found alongside the executable which will be created after the first run.

## Exiting

Right clicking anywhere on the bar will open a context menu containing the option to exit.

You can also kill `sambar.exe` from the task manager or by running `taskkill /IM sambar.exe` from cmd/pwsh. Even while running the terminal, since the bar window runs on its own UI thread the `Main()` returns immediately, so `Ctrl-C` wont work to kill sambar.

# Widgets

Widgets are organized into a `Pack`. They are a collection of widgets. You can see them in the `WidgetPacks` folder. `sambar.exe` looks for this folder in the location where the binary is located. A basic set of widgets have been already written for you in the `Base` widget pack. You can include them or copy and modify them to create your own widget packs.

Each widget pack is folder in the `WidgetPacks` folder. To create your own widget pack, first create a folder in `WidgetPacks` and give it the name you want. You will notice that in the `widgetPacks` folder there is a file called `.init.cs`. Sambar will look for this file in order to determine which widgetPack you want to use. So inorder to use the widget pack you have created, change the `return "Base"` in `init.cs` to `return "<YOUR WIDGETPACKNAME>"` where the `WIDGETPACKNAME` is the folder name you specified before.

But your newly created widgetpack is empty. So you need to create some widgets. If your merely want to modify existing widgets, modifying them in `Base` is enough. But if you want to create a new layout or a layout with different colors, its better to create a new widget pack.

To start hacking with sambar have a go at [Tutorials](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials/Landing.md)



================================================================================
FILE: :\DEV\sambar\Docs\Configuration.md
SIZE: 2.81 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Configuration

Code and configuration are the same. Everything configurable in Sambar are present in `.cs` files in the `WidgetPacks` folder. There are no `json` or `yaml` files. At its core sambar exposes an api and is a script runner. With this approach it is possible to customize sambar to its fullest extend. You are not limited to the customization thats exposed by a widget, instead you can customize the widget yourself.

## Directory Structure

```
   WidgetPacks
   â”œâ”€â”€â”€Base
   â”‚   â””â”€â”€â”€assets
   â”‚   .config.cs
   â”‚   .layout.cs
   â”‚   .theme.cs
   â”‚   <-->.widget.cs
   â””â”€â”€â”€Plain1
       .config.cs
       .layout.cs
       .imports.cs
       .theme.cs
   .init.cs
```

A widgetpack is a the fundamental unit composed of a collection of widgets and configuration files necessary for a fully functional bar with a certain style/theme.

Each widget pack contains a set of widgets (ending with `.widget.cs` extensions) and a set of configuration files (or dotfiles): `.config.cs`, `.layout.cs`, `.theme.cs`

The root WidgetPacks folder contains an `.init.cs` file. Sambar will use the widgetpack returned from this file.

Lets have a look at these files in depth: 

#### `.config.cs` : 

Configure the primary properties of the bar window that are necessary during launch, these (and their default values) are:

```cs
int height = 40;
int width = 0;
int marginXLeft = 10;
int marginXRight = 10;
int marginYTop = 10;
int paddingXLeft = 0;
int paddingXRight = 0;
int paddingYTop = 0;
int paddingYDown = 0;
string backgroundColor = "";
bool roundedCorners = true;
string borderColor = "";
int borderThickness = 0;
string widgetPack = "Base";
```

#### `.layout.cs`: 

This file basically defines the layout of all the widgets in the sambar bar. Their positioning, sizes, everything. Refer to [constructing the widgets layout]() for a detailed look into creating or changing the layout of sambar.

#### `.theme.cs`: 

This file contains a static class called `Theme` which can hold global variables for common use by your widgets. Say `TEXT_COLOR` for example and you need a common text color in all your widgetsfor creating a particular theme. Then you can make that as a variable in here. They can be called from the widgets easily as `Theme.TEXT_COLOR`.

#### `.init.cs`:

contains a single return statement

```cs
return "<WIDGETPACKNAME>";
```

#### `.imports.cs`:

Notice in `Plain1` widgetpack there's another file called `.imports.cs`. Well `Plain1` is just a slight modification of the `Base` widgetpack and therefore "imports" the default widgets from `Base` without any modification to the widgets themselves. This is so that you dont have to copy unmodified `.widget.cs` files if all you need is to have them as it is in your new widgetpack/theme.





================================================================================
FILE: :\DEV\sambar\Docs\Landing.md
SIZE: 0.8 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Welcome to sambar docs !

The docs cover everything you need to successfully run, configure and develop plugins for the sambar status bar.
Have a quick rundown through basics to get started with setting up sambar, how to launch the app, read the logs etc.
For more indepth topics such as configuring the widgets or even creating new ones, go through the tutorial. While developing
new plugins the Sambar Api is incredibly useful, see the Api reference here.

 1. [Basics](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Basics.md)
 2. [Configuration](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Configuration.md)
 3. [Tutorials](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials.md)
 4. [Api](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Api.md)



================================================================================
FILE: :\DEV\sambar\Docs\project_export.txt
SIZE: 11.12 KB
MODIFIED: 09/25/2025 15:08:20
================================================================================




================================================================================
FILE: :\DEV\sambar\Docs\Showcase\Landing.md
SIZE: 0 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

[EMPTY FILE]


================================================================================
FILE: :\DEV\sambar\Docs\Tutorials\Landing.md
SIZE: 0.23 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Tutorials

 1. [Creating a widget](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials/Widgets.md)
 2. [Configuring the layout](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Tutorials/Layout.md)



================================================================================
FILE: :\DEV\sambar\Docs\Tutorials\Layout.md
SIZE: 2.39 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Layout

## Creating a layout

 1. In the `WidgetPack` of your choice create a `.layout.cs` file.
 2. A layout class must inherit from the base `Layout` class.

```cs
class MyNewLayout: Layout 
{
    public MyNewLayout() 
    {

    }
}
```

Now what is a layout ? Its like a blueprint right where you lay out a plan depicting where your widgets are finally going to appear on the bar. So first, like in all plans you have to create placeholders demarking positions for each of your widgets. These placeholders would then be arranged in the way you want them to be, and thats your layout. The `WidgetEngine` when processing the Layout object would fill these placeholders with the unique widgets they were designated with.

Seems pretty straightforward, right ?

Okay then, the placeholders are `Border`s in WPF. So for each widget you have to create a field in the Layout class thats of type `Border`. Lets say that I have two widgets named `MyWidget1` and `MyWidget2`, then it would look like this:

```cs
class MyNewLayout: Layout 
{
    // placeholders
    Border MyWidget1;
    Border MyWidget2;

    public MyNewLayout() 
    {

    }
}
```

Now you can arange these placeholders as if they were the actual widgets and in the end they would be filled with their respective widgets.

**PS: The field's name must match exactly as that of their widget's (the widget's class to be precise)**

Now who do you arrange these placeholders ?

First you will have to choose a master layout for the whole container, like `Grid` or `StackPanel` you know, the usual kinds we have in WPF. Once you have done that you must add your placeholder borders to these containers. For simplicity i will choose a simply horizontally oriented stackpanel as my container.

```cs
class MyNewLayout: Layout 
{
    // placeholders
    Border MyWidget1;
    Border MyWidget2;

    public MyNewLayout() 
    {
        StackPanel panel = new();
        this.Container = panel;
    }
}
```

Now just add those placeholders to the panel which is my container.

```cs
class MyNewLayout: Layout 
{
    // placeholders
    Border MyWidget1;
    Border MyWidget2;

    public MyNewLayout() 
    {
        StackPanel panel= new();
        panel.Children.Add(MyWidget1);
        panel.Children.Add(MyWidget2);
        this.Container = panel;
    }
}
```

And just like that your layout is finished.




================================================================================
FILE: :\DEV\sambar\Docs\Tutorials\Widgets.md
SIZE: 2.26 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Creating a widget

Inorder to create a new widget for your new widget pack, follow along !

 1. Inside your widgetpack folder (`WidgetPacks\<MyWidgetPack>`) create a file named, `MyNewWidget.widget.cs`.
 2. Create your widget class names `MyNewWidget` which inherits from the base `Widget` class.
 
 this is what it looks like now:

```cs
class MyNewWidget: Widget 
{
    public MyNewWidget() 
    {

    }
}
```

Now all widgets upon being instantiated by the [`WidgetLoader`](https://github.com/TheAjaykrishnanR/sambar/blob/29edadad7b02062c92393803413cef43dcc99755/Src/Classes/Engine/WidgetEngine.cs#L30) recieves an environment variable `ENV` of type [`WidgetEnv`](https://github.com/TheAjaykrishnanR/sambar/blob/29edadad7b02062c92393803413cef43dcc99755/Src/Classes/Engine/Widget.cs#L38). This is done so that the widget can know and access certain information that might only be available at runtime. So pass this to the constructor of your new widget as follows:

```cs
class MyNewWidget: Widget 
{
    public MyNewWidget(WidgetEnv ENV) 
    {

    }
}
```

you know what ? lets just even initialize the base constructor with `ENV`:

```cs
class MyNewWidget: Widget 
{
    public MyNewWidget(WidgetEnv ENV): base(ENV)
    {

    }
}
```

Now thats all done, lets actuall go back to creating our widget. You can literally do anything you want in here at this point, but for illustration lets write a simple widget that displays the text "Hello, World!" on the bar. Do the following:

```cs
class MyNewWidget: Widget 
{
    public MyNewWidget(WidgetEnv ENV): base(ENV)
    {
        TextBock textBlock = new();
        textBlock.Text = "Hello, World!";
    }
}
```

Now we have created the `TextBlock` but we still need to set the text block as the content of our widget, so do:

```cs
class MyNewWidget: Widget 
{
    public MyNewWidget(WidgetEnv ENV): base(ENV)
    {
        TextBock textBlock = new();
        textBlock.Text = "Hello, World!";
        // set the widget content as our textblock
        this.Content = textBlock;
    }
}
```

Now thats it ! Provided that `MyNewWidget` has been added in the `.layout.cs` to specify where the widget should be on the bar, you should see "Hello, World!" next time you launch sambar.





================================================================================
FILE: :\DEV\sambar\README.md
SIZE: 2.76 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

# Sambar

![GitHub Downloads (all assets, all releases)](https://img.shields.io/github/downloads/TheAjaykrishnanR/sambar/total?color=green)

![showcase_1](https://github.com/TheAjaykrishnanR/sambar/blob/master/Imgs/explorer_fi1Oz9MPqd.gif)
> **A native status bar for Windows 11 written in C# (.NET) with love â¤ï¸. Utilizes the WPF technology and native interop to 
provide a rich set of functionalities which can be consumed through widgets. You can write your own widgets utilizing
the functions and events provided throug the API to spare yourself from reinventing the wheel everytime. Or you can even 
leverage the C# standard library and build features from scratch. Everything is configurable: The layout, dimensions,
positions and colors are <ins>fully customizable</ins>. [dive in?](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Landing.md)**

<ins>Sources and inspirations</ins>:

 - [yasb](https://github.com/amnweb/yasb)
 - [Seelen-UI](https://github.com/eythaann/Seelen-UI)
 - [zebar](https://github.com/glzr-io/zebar)

## Features

 - Native (WPF), lightweight and less resource intensive
 - Widget support

 <ins>currently available widgets</ins>:

 1. [GlazeWM](https://github.com/glzr-io/glazewm) workspaces
 2. Tray icons
 3. Taskbar apps
 4. Buttons (Start, Action Center)
 5. Toggle native taskbar
 6. Performance counters (CPU, Memory, Network)
 7. Audio visualizer
 8. Media playback information
 9. Network Manager (open actions center)
 10. Hide the default windows taskbar
 11. Animated Wallpaper changer

## Usage

Download the latest release from [here](https://github.com/TheAjaykrishnanR/sambar/releases)

## Requirements

 1. Windows 11 build 26100+
 2. .NET 9 Desktop Runtime (if you aren't running the self-contained version), download and install it from [here](https://dotnet.microsoft.com/en-us/download/dotnet/9.0/runtime)

 ## Documentation and Tutorials

Read the [docs](https://github.com/TheAjaykrishnanR/sambar/blob/master/Docs/Landing.md) here.

PS: *docs currently under construction and therefore incomplete*

## Building

 1. Download and Install .NET 9 SDK
 2. `git clone https://github.com/TheAjaykrishnanR/sambar`
 3. `cd Src`
 4. `dotnet build`

### To publish a self contained executable:

 1. `cd Src`
 2. `dotnet publish -r win-x64 -p:PublishSingleFile=true --self-contained -c Release`

You can find the executable at `bin\Release\net*\win-x64\publish`

## Acknowledgements

Sambar wouldnt have been possible without the existence of all the libraries it depends on.
Thanks to :
 1. `NAudio`
 2. `Newtonsoft.Json`
 3. `ScottPlot`
 4. `SkiaSharp`

## Contributing

PRs welcome !

## License

This project is free to use, modify and distribute according to the MIT License.




================================================================================
FILE: :\DEV\sambar\Src\AssemblyInfo.cs
SIZE: 0.63 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System.Windows;

[assembly:ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Api.cs
SIZE: 1.09 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Drawing;
using System.Diagnostics;
using System.Windows;
using Interop.UIAutomationClient;

namespace sambar;

/// <summary>
/// The entire Api class provides core functionalities that a widget developer
/// can use in their plugins so that they dont have to reinvent the wheel.
/// </summary>
public partial class Api
{

	public List<Task> initTasks = new();
	internal Api(Sambar bar)
	{
		this.bar = bar;

		EventsInit();
		ToggleTaskbarInit();
		WindowingInit();
		SystemInit();
		SystemTrayInit();
		TaskbarInterceptorInit();
		ClockInit();
		CountersInit();
		initTasks.AddRange([
			Task.Run(GlazeInit),
			Task.Run(AudioInit)
		]);
	}

	public void Print(string text)
	{
		Logger.Log(text);
	}

	// so that widgets and scripts can use it
	public Config config;

	// instance of mainWindow
	public Sambar bar;

	// IUIAutomation
	CUIAutomation ui = new();

	internal void Cleanup()
	{
		ToggleTaskbarCleanup();
		GlazeCleanup();
	}
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Audio.cs
SIZE: 9.45 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using NAudio.Wave;
using NAudio.CoreAudioApi;
using NAudio.Dsp;
using ScottPlot;
using ScottPlot.WPF;
using System.Windows;
using FftSharp;
using System.Numerics;
using System.Windows.Media;
using Colors = System.Windows.Media.Colors;
using System.Collections.Immutable;
using ScottPlot.Plottables;
using SkiaSharp;
using ScottPlot.DataSources;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Drawing;
using Windows.Media.Control;

namespace sambar;

public partial class Api
{
	WasapiLoopbackCapture systemAudioCapture = new();
	AudioMeterInformation? audioMeterInformation = null;

	const int SAMPLE_RATE = 44100;
	const int BITS = 16;
	const int CHANNELS = 2;
	const int SAMPLE_WIDTH = (BITS / sizeof(byte)) * CHANNELS;
	const int TIME_SLICE = 100;
	const int SAMPLES_IN_TIME_SLICE = SAMPLE_RATE * TIME_SLICE / 1000;
	const int BYTES_IN_TIME_SLICE = SAMPLES_IN_TIME_SLICE * SAMPLE_WIDTH * (BITS / sizeof(byte));

	WaveFormat waveFormat = new(SAMPLE_RATE, BITS, CHANNELS);
	// initialized in CreateAudioVisualizer()
	WpfPlot audioVisPlot;
	FilledSignal audioSignal;
	//Signal audioSignal;

	GlobalSystemMediaTransportControlsSessionManager gsmtcsm;
	private async void AudioInit()
	{
		systemAudioCapture.WaveFormat = waveFormat;

		MMDeviceEnumerator deviceEnumerator = new();
		MMDevice? defaultSpeaker = deviceEnumerator.GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia);
		audioMeterInformation = defaultSpeaker?.AudioMeterInformation;

		System.Timers.Timer audioTimer = new(TIME_SLICE);
		audioTimer.Elapsed += AudioTimer_Elapsed;
		audioTimer.Start();

		// Track info
		gsmtcsm = await GlobalSystemMediaTransportControlsSessionManager.RequestAsync();
	}

	public delegate void MediaInfoEventHandler(MediaInfo mediaInfo);
	public event MediaInfoEventHandler MEDIA_INFO_EVENT = (info) => { };
	public delegate void MediaStoppedEventHandler();
	public event MediaStoppedEventHandler MEDIA_STOPPED_EVENT = () => { };

	// FIX_TODO: When audio gets quiet while a track is playing, instead of 
	// cleaning or vanishing to 0, some garbage signal is plotted, cant understand
	// why naudio is generating those, or if thats whats causing it at all
	readonly double GIBBERISH_OFFSET = 0.01;
	private void AudioTimer_Elapsed(object? sender, System.Timers.ElapsedEventArgs e)
	{
		if (audioMeterInformation?.MasterPeakValue > GIBBERISH_OFFSET)
		{
			if (systemAudioCapture.CaptureState == CaptureState.Stopped)
			{
				systemAudioCapture.DataAvailable += SystemAudioCapture_DataAvailable;
				systemAudioCapture.StartRecording();
			}
			MEDIA_INFO_EVENT(GetMediaInfo().Result);
			//Logger.Log($"Audio Playing ... {audioMeterInformation?.MasterPeakValue}", file: false);
		}
		else
		{
			if (systemAudioCapture.CaptureState == CaptureState.Capturing)
			{
				systemAudioCapture.StopRecording();
				systemAudioCapture.DataAvailable -= SystemAudioCapture_DataAvailable;
			}
			MEDIA_STOPPED_EVENT();
			CleanScottPlot();
			//Logger.Log($"Audio Stopped... {audioMeterInformation?.MasterPeakValue}", file: false);
		}
	}

	// does not fire at fixed intervals which can be specified manually
	private void SystemAudioCapture_DataAvailable(object? sender, WaveInEventArgs e)
	{
		byte[] bytes = e.Buffer.Take(e.BytesRecorded).ToArray();
		float[] samples = GetSamples(bytes);
		double[] amplitudes = new double[samples.Length];
		Array.Copy(samples, amplitudes, amplitudes.Length);

		// fast fourier transfor for frequencies from amplitudes
		double[] zeroPaddedAmplitudes = Pad.ZeroPad(amplitudes);
		System.Numerics.Complex[] complexFrequencyDistribution = FFT.Forward(zeroPaddedAmplitudes);
		double[] frequencyWeights = FFT.Magnitude(complexFrequencyDistribution);

		// amplitude plot
		//plot.Plot.Axes.SetLimitsY(-1, 1);
		//plot.Plot.Axes.SetLimitsX(0, SAMPLES_IN_TIME_SLICE);
		//UpdateScottPlot(amplitudes, SAMPLE_RATE/1000);

		// frequency plot
		double signalPeriod = 1.0f / ((double)frequencyWeights.Length / SAMPLE_RATE);
		UpdateScottPlot(frequencyWeights, signalPeriod);
	}
	// Scale signal so that it looks good on ScottPlot
	void ScaleSignal(double[] arr)
	{
		double min = arr.Min();
		double max = arr.Max();
		double range = max - min;
		double clip = 0.6; // 0 < clip < 1
		double compressor = 0.2; // 0 < compressor < 1
		double gain = 1.5; // 1 < gain < inf
		double offset = 0.08;
		if (range == 0) return;
		for (int i = 0; i < arr.Length; i++)
		{
			// normalize
			arr[i] = (arr[i] - min) / range;
			// clip
			if (arr[i] > clip)
				arr[i] *= compressor;
			// add gain
			else
				arr[i] *= gain;
			// shift by offset
			arr[i] += offset;
		}
	}

	bool firstRender = true;
	List<double> signalData = new();
	private void UpdateScottPlot(double[] signalData, double signalPeriod)
	{
		ScaleSignal(signalData);
		// WpfPlot holds a reference to "this.signalData", so just update it
		WriteArrayToListAndTrim<double>(signalData, this.signalData);
		if (firstRender)
		{
			firstRender = false;
			// if audio is playing while bar is launched this hits before
			// CreateAudioVisualizer() is called, if thats the case initialize
			// audio signal here
			if (audioSignal == null)
			{
				//audioSignal = audioVisPlot.Plot.Add.Signal(this.signalData, signalPeriod);
				audioSignal = FilledSignal.AddFilledSignalToPlot(audioVisPlot, this.signalData, signalPeriod);
			}
			else
			{
				audioSignal.Data.Period = signalPeriod;
			}
		}
		//audioVisPlot?.Plot.Axes.SetLimitsX(0, 20000);
		audioVisPlot?.Plot.Axes.AutoScaleX();
		audioVisPlot?.Plot.Axes.SetLimitsY(0, 1);

		audioVisPlot?.Refresh();
	}

	private static void WriteArrayToListAndTrim<T>(T[] array, List<T> list)
	{
		for (int i = 0; i < array.Length; i++)
		{
			if (i >= list.Count) list.Add(array[i]);
			else list[i] = array[i];
		}
		list.RemoveRange(array.Length - 1, list.Count - array.Length);
	}

	// Samples are the amplitudes
	private float[] GetSamples(byte[] bytes)
	{
		// total bytes recorded = samples * bytes per sample * channels
		// 16 bit = 2 bytes => bytes per sample
		int samplesCount = bytes.Length / SAMPLE_WIDTH;

		// each sample has an amplitude
		float[] samples = new float[samplesCount];

		// for simplicity choose the first channel
		for (int i = 0; i < samplesCount; i++)
		{
			// [ ..., 0x00, 0x10, ...]
			//        ^(i)  ^(i+1) 
			//            <-| shift to the left halfway (16/2 = 8 bits)
			short sample = (short)(bytes[i * SAMPLE_WIDTH] | bytes[i * SAMPLE_WIDTH + 1] << 8);
			samples[i] = sample / 32768f;
		}

		return samples;
	}

	private async Task<MediaInfo> GetMediaInfo()
	{
		var mediaProperties = await gsmtcsm.GetCurrentSession().TryGetMediaPropertiesAsync();
		return new MediaInfo()
		{
			Title = mediaProperties.Title,
			Artist = mediaProperties.Artist,
		};
	}

	private async void CleanScottPlot()
	{
		await Task.Delay(10);
		for (int i = 0; i < this.signalData.Count; i++)
		{
			this.signalData[i] = 0;
		}
		audioVisPlot?.Refresh();
	}
}

// custom ScottPlot.Plottables.Signal class that supports filling the insides of the 
// signal plot
public class FilledSignal : Signal
{
	public System.Drawing.Color fillColor = System.Drawing.Color.Blue;
	public FilledSignal(ISignalSource data) : base(data) { }
	public override void Render(RenderPack rp)
	{
		if (!IsVisible) return;
		if (!Data.GetYs(MinRenderIndex, MaxRenderIndex).Any()) return;

		CoordinateRange visibleXRange = GetVisibleXRange(Axes.DataRect);
		int index = Data.GetIndex(visibleXRange.Min, clamp: true);
		int index2 = Data.GetIndex(visibleXRange.Max + Data.Period, clamp: true);
		List<Pixel> list = new List<Pixel>();
		for (int i = index; i <= index2; i++)
		{
			float pixelX = Axes.GetPixelX(Data.GetX(i));
			float pixelY = Axes.GetPixelY(Data.GetY(i) * Data.YScale + Data.YOffset);
			Pixel item = new Pixel(pixelX, pixelY);
			list.Add(item);
		}
		using SKPath sKPath = new SKPath();
		float magicYVal = Axes.YAxis.GetPixel(0, rp.DataRect); // magic yVal, idk why it works and a simple 0 doesnt ??
		sKPath.MoveTo(new SKPoint() { X = list[0].X, Y = magicYVal });
		foreach (Pixel item2 in list)
		{
			sKPath.LineTo(item2.ToSKPoint());
		}
		sKPath.LineTo(new SKPoint() { X = list.Last().X, Y = magicYVal });
		sKPath.Close();
		using SKPaint sKPaint = new SKPaint();
		LineStyle.ApplyToPaint(sKPaint);

		// draw fill
		FillStyle FillStyle = new() { IsVisible = true, Color = new(fillColor) };
		PixelRect pixelRect = new();
		FillStyle.ApplyToPaint(sKPaint, pixelRect);
		rp.Canvas.DrawPath(sKPath, sKPaint);
	}

	private CoordinateRange GetVisibleXRange(PixelRect dataRect)
	{
		double coordinateX = Axes.GetCoordinateX(dataRect.Left);
		double coordinateX2 = Axes.GetCoordinateX(dataRect.Right);
		if (!(coordinateX <= coordinateX2))
		{
			return new CoordinateRange(coordinateX2, coordinateX);
		}
		return new CoordinateRange(coordinateX, coordinateX2);
	}

	public static FilledSignal AddFilledSignalToPlot(WpfPlot audioVisPlot, List<double> signalData, double? signalPeriod = null)
	{
		SignalSourceDouble signalSource;
		if (signalPeriod == null)
			signalSource = new(signalData, 1);
		else
			signalSource = new(signalData, (double)signalPeriod);
		FilledSignal audioSignal = new(signalSource);
		audioVisPlot.Plot.PlottableList.Add(audioSignal);
		return audioSignal;
	}
}

public class MediaInfo
{
	public string Title;
	public string Artist;
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Clocks.cs
SIZE: 0.86 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

namespace sambar;

public partial class Api
{
    public delegate void ClockTickedEventHandler(Time time);
    public event ClockTickedEventHandler CLOCK_TICKED = (time) => { };
    private void ClockInit()
    {
        Task.Run(async () =>
        {
            while(true)
            {
                Time now = new();
                CLOCK_TICKED(now);
                await Task.Delay(1000);
            }
        });
    }

    // Api Endpoint
    // Set polling frequence / event firing rate
}

public class Time
{
    public int seconds = DateTime.Now.Second;
    public int minutes = DateTime.Now.Minute;
    public int hours = DateTime.Now.Hour;
    public int day = DateTime.Now.Day;
    public int month = DateTime.Now.Month;
    public int year = DateTime.Now.Year;
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Counters.cs
SIZE: 5.24 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net.NetworkInformation;

namespace sambar;

public partial class Api
{

	int cpuCores = 0;
	public void CountersInit()
	{
		cpuCores = GetCpuCount();
		StartCpuMonitor();
		StartNetworkMonitor();
		StartMemoryMonitor();
	}

	public int GetCpuCount()
	{
		SYSTEM_BASIC_INFORMATION sbi = new();
		Ntdll.NtQuerySystemInformation(
			SYSTEM_INFORMATION_CLASS.SystemBasicInformation,
			ref sbi,
			(uint)Marshal.SizeOf<SYSTEM_BASIC_INFORMATION>(),
			out uint returnLength
		);
		int coreCount = sbi.NumberOfProcessors;
		Logger.Log($"CORECOUNT: {coreCount}");
		return coreCount;
	}

	public delegate void CpuPerformanceEventHandler(long[] cpuStats);
	public event CpuPerformanceEventHandler CPU_PERFORMANCE_NOTIFIED = (stats) => { };
	/// <summary>
	/// Get CPU Usages
	/// https://www.codeproject.com/Articles/9113/Get-CPU-Usage-with-GetSystemTimes
	/// </summary>
	public void StartCpuMonitor()
	{
		if (cpuCores == 0) return;

		CancellationTokenSource cts = new();
		long[] cpuStats = new long[cpuCores];
		Task.Run(async () =>
		{
			long[] usr = new long[cpuCores];
			long[] kernel = new long[cpuCores];
			long[] idle = new long[cpuCores];

			long[] _usr = new long[cpuCores];
			long[] _kernel = new long[cpuCores];
			long[] _idle = new long[cpuCores];

			long[] _delta_usr = new long[cpuCores];
			long[] _delta_kernel = new long[cpuCores];
			long[] _delta_idle = new long[cpuCores];

			while (true)
			{
				int size = Marshal.SizeOf<SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION>();
				nint bufferPtr = Marshal.AllocHGlobal(size * cpuCores);
				Ntdll.NtQuerySystemInformation(
					SYSTEM_INFORMATION_CLASS.SystemProcessorPerformanceInformation,
					bufferPtr,
					(uint)(size * cpuCores),
					out uint returnLength
				);

				for (int i = 0; i < cpuCores; i++)
				{
					SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION proc =
						Marshal.PtrToStructure<SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION>(bufferPtr + size * i);

					_usr[i] = usr[i];
					_kernel[i] = kernel[i];
					_idle[i] = idle[i];

					usr[i] = proc.UserTime;
					kernel[i] = proc.KernelTime;
					idle[i] = proc.IdleTime;

					_delta_usr[i] = usr[i] - _usr[i];
					_delta_kernel[i] = kernel[i] - _kernel[i];
					_delta_idle[i] = idle[i] - _idle[i];

					long total = _delta_usr[i] + _delta_kernel[i];
					long active = total - _delta_idle[i];
					cpuStats[i] = active * 100 / total;
				}

				CPU_PERFORMANCE_NOTIFIED(cpuStats);
				long cpuTotalUsage = 0;
				cpuStats.ToList().ForEach(x => cpuTotalUsage += x);
				Marshal.FreeHGlobal(bufferPtr);
				//Logger.Log($"CPU TOTAL: {cpuTotalUsage / cpuCores}%");
				await Task.Delay(1000);
			}
		}, cts.Token);
	}


	public delegate void NetworkSpeedEventHandler(float[] speeds);
	public event NetworkSpeedEventHandler NETWORK_SPEED_NOTIFIED = (speeds) => { };
	/// <summary>
	/// Network monitor
	/// </summary>
	public void StartNetworkMonitor()
	{
		CancellationTokenSource cts = new();
		Task.Run(async () =>
		{
			Logger.Log($"STARTING NETWORK MONITOR");
			var primaryInterface = Utils.GetPrimaryNetworkInterface();
			long downBytes = 0, _downBytes = 0, upBytes = 0, _upBytes = 0, _delta_downBytes = 0, _delta_upBytes = 0;
			int DELTA = 1000; // milliseconds
			while (true)
			{
				_downBytes = downBytes;
				_upBytes = upBytes;

				downBytes = primaryInterface.GetIPv4Statistics().BytesReceived;
				upBytes = primaryInterface.GetIPv4Statistics().BytesSent;

				_delta_downBytes = downBytes - _downBytes;
				_delta_upBytes = upBytes - _upBytes;

				// speeds are in Kb/s
				float speedDown = ((float)_delta_downBytes * 8) / (DELTA / 1000) / 1024;
				float speedUp = ((float)_delta_upBytes * 8) / (DELTA / 1000) / 1024;
				NETWORK_SPEED_NOTIFIED([speedDown, speedUp]);
				//Logger.Log($"DOWN: {speedDown} Kb/s, UP: {speedUp} Kb/s");
				await Task.Delay(DELTA);
			}
		}, cts.Token);
	}

	public delegate void MemoryUsageEventHandler(float[] memoryUsage);
	public event MemoryUsageEventHandler MEMORY_USAGE_NOTIFIED = (memoryUsage) => { };
	/// <summary>
	/// Memory usage monirtor
	/// </summary>
	public void StartMemoryMonitor()
	{
		CancellationTokenSource cts = new();
		Task.Run(async () =>
		{
			int infoSize = Marshal.SizeOf<_SYSTEM_MEMORY_USAGE_INFORMATION>();
			while (true)
			{
				nint infoPtr = Marshal.AllocHGlobal(infoSize);
				Ntdll.NtQuerySystemInformation(
					SYSTEM_INFORMATION_CLASS.SystemMemoryUsageInformation,
					infoPtr,
					(uint)infoSize,
					out uint returnLength
				);

				var info = Marshal.PtrToStructure<_SYSTEM_MEMORY_USAGE_INFORMATION>(infoPtr);


				float commited = (float)info.CommittedBytes / 1024 / 1024 / 1024; // in GB
				float available = (float)info.AvailableBytes / 1024 / 1024 / 1024;
				float totalPhysical = (float)info.TotalPhysicalBytes / 1024 / 1024 / 1024;
				//Logger.Log($"[ MEMORY ], commited: {commited} Gb, available: {available} Gb, totalPhysical: {totalPhysical} Gb ");
				Marshal.FreeHGlobal(infoPtr);
				MEMORY_USAGE_NOTIFIED([available, totalPhysical]);
				await Task.Delay(1000);
			}
		}, cts.Token);
	}
}






================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\CustomWindows.cs
SIZE: 5.02 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

///<summary>
/// Custom windows that can be used by widgets to make detached plugins
/// such as clocks, audio visualizers or whatever one so desires. Because it
/// doesnt fit inside Menus.cs
///</summary>

using System.Windows;
using System.Windows.Controls;
using System.Windows.Interop;
using System.Windows.Media;
using ScottPlot;
using ScottPlot.WPF;
using WinRT;
using ScottPlot.Plottables;
using FlaUI.Core.WindowsAPI;
using SkiaSharp;
using SkiaSharp.Views.WPF;

namespace sambar;

public partial class Api
{
	private void CustomWindowsInit()
	{

	}

	public (ThreadWindow, WpfPlot, FilledSignal) CreateAudioVisualizer(
		int x = 100,
		int y = 100,
		int width = 400,
		int height = 200,
		bool centerOffset = false,
		Action<Window>? init = null
	)
	{
		if (centerOffset)
			(x, y) = GetCenteredCoords(x, y, width, height);

		ThreadWindow threadWnd = new(x, y, width, height, init);
		threadWnd.Run(() =>
		{
			audioVisPlot = new();
			//audioSignal = audioVisPlot!.Plot.Add.Signal(this.signalData);
			audioSignal = FilledSignal.AddFilledSignalToPlot(this.audioVisPlot, this.signalData);
			// WpfPlot does not automatically get its dimensions when inside a container like
			// stackpanel or border, therefore width and height must be set manually
			audioVisPlot.Height = 100;
			audioVisPlot.Width = 200;
		});
		return (threadWnd, audioVisPlot, audioSignal);
	}

	public Window CreateWidgetWindow(int x, int y, int width, int height, bool centerOffset = false)
	{
		if (centerOffset)
			(x, y) = GetCenteredCoords(x, y, width, height);

		WidgetWindow wnd = new()
		{
			Title = "sambarWidgetWindow",
			Background = new SolidColorBrush(System.Windows.Media.Colors.Black),
			Left = x,
			Top = y,
			Width = width,
			Height = height,
		};
		return wnd;
	}

	public (int, int) GetCenteredCoords(int offsetX, int offsetY, int width, int height)
	{
		offsetX += (Sambar.screenWidth - width) / 2;
		offsetY += (Sambar.screenHeight - height) / 2;
		return (offsetX, offsetY);
	}

	private Window _overlayWnd;
	public Window activeOverlayWnd
	{
		get { return _overlayWnd; }
		set
		{
			_overlayWnd?.Close();
			_overlayWnd = value;
		}
	}
	public Window CreateDesktopOverlay()
	{
		activeOverlayWnd = new WidgetWindow()
		{
			Title = "sambarDesktopOverlaly",
			Background = new SolidColorBrush(System.Windows.Media.Colors.Black),
			Left = 0,
			Top = 0,
			Width = Sambar.screenWidth,
			Height = Sambar.screenHeight,
		};
		return activeOverlayWnd;
	}
}

/// <summary>
/// Non focusable window that always remains bottom most (also hidden in alt-tab).
/// </summary>
public class WidgetWindow : Window
{
	public nint hWnd;
	internal WidgetWindow()
	{
		this.ShowActivated = false;
		this.AllowsTransparency = true;
		this.WindowStyle = WindowStyle.None;
		this.ResizeMode = ResizeMode.NoResize;

		hWnd = new WindowInteropHelper(this).EnsureHandle();
		Utils.HideWindowInAltTab(hWnd);
		SetBottom();

		HwndSource hWndSrc = HwndSource.FromHwnd(hWnd);
		HwndSourceHook hook = new(WndProc);
		hWndSrc.AddHook(hook);
		this.Closing += (s, e) =>
		{
			hWndSrc.RemoveHook(hook);
		};
	}

	private nint WndProc(nint hWnd, int msg, nint wparam, nint lparam, ref bool handled)
	{
		if (msg == (int)WINDOWMESSAGE.WM_SETFOCUS ||
			msg == (int)WINDOWMESSAGE.WM_ACTIVATE ||
			msg == (int)WINDOWMESSAGE.WM_MOUSEACTIVATE ||
			msg == (int)WINDOWMESSAGE.WM_WINDOWPOSCHANGING ||
			msg == (int)WINDOWMESSAGE.WM_ACTIVATEAPP
		)
		{
			SetBottom();
			handled = true;
		}

		return 0;
	}

	private void SetBottom()
	{
		User32.SetWindowPos(hWnd, (nint)SWPZORDER.HWND_BOTTOM, 0, 0, 0, 0, SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOACTIVATE);
	}
}

/// <summary>
/// A wrapper for a window that runs on a separate thread.
/// </summary>
public class ThreadWindow
{
	public WidgetWindow? wnd;
	public nint hWnd;
	public FrameworkElement? content;
	bool initialized = false;
	internal ThreadWindow(
		int x = 100,
		int y = 100,
		int width = 800,
		int height = 400,
		Action<Window>? init = null
	)
	{
		Thread thread = new(() =>
		{
			wnd = new();
			wnd.Title = "sambarThreadedWindow";
			wnd.Left = x;
			wnd.Top = y;
			wnd.Width = width;
			wnd.Height = height;
			// just do this before show()
			init?.Invoke(wnd);
			hWnd = new WindowInteropHelper(wnd).EnsureHandle();
			initialized = true;

			// make thread a "UI Thread" by starting the message pump
			System.Windows.Threading.Dispatcher.Run();
		});
		thread.SetApartmentState(ApartmentState.STA);
		thread.IsBackground = true;
		thread.Start();
	}

	public ThreadWindow EnsureInitialized()
	{
		while (!initialized) Thread.Sleep(1);
		return this;
	}

	public void Run(Action runLambda)
	{
		while (!initialized) Thread.Sleep(1);
		bool finished = false;
		wnd?.Dispatcher.Invoke(() =>
		{
			runLambda();
			finished = true;
		});
		while (!finished) Thread.Sleep(1);
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Events.cs
SIZE: 4.59 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using Windows.Devices.SmartCards;
using Interop.UIAutomationClient;

namespace sambar;

public partial class Api
{
    public void EventsInit()
    {
        FOCUS_CHANGED_EVENT = (msg) => { };
        FocusChangedEventHandlerClass focusChangedHandlerObject = new();
        ui.AddFocusChangedEventHandler(null, focusChangedHandlerObject);

        STRUCTURE_CHANGED_EVENT = (msg) => { };
        StructureChangedEventHandlerClass structureChangedHandlerObject = new();
        ui.AddStructureChangedEventHandler(ui.GetRootElement(), TreeScope.TreeScope_Children, null, structureChangedHandlerObject);
    }

    public delegate void FocusChangedEventHandler(FocusChangedMessage msg);
    public static event FocusChangedEventHandler FOCUS_CHANGED_EVENT;
    class FocusChangedEventHandlerClass: IUIAutomationFocusChangedEventHandler
    {
        public void HandleFocusChangedEvent(IUIAutomationElement sender)
        {
            //Logger.Log($"focusChangedEvent, name: {sender.CurrentName}, windowClass: {sender.CurrentClassName}, type: {sender.CurrentItemType}");
            try
            {
                FocusChangedMessage msg = new();
                msg.className = sender.CurrentClassName;
                msg.type = sender.CurrentItemType;
                msg.name = sender.CurrentName;
                msg.hWnd = sender.CurrentNativeWindowHandle;
                msg.controlType = (ControlType)sender.CurrentControlType;
                msg.sender = sender;
                FOCUS_CHANGED_EVENT(msg);
            }
            catch(Exception ex)
            {
                Logger.Log($"UIAutomation, HandleFocusChangedEvent: {ex.Message}");
            }
        }
    }

    public delegate void StructureChangedEventHandler(StructureChangedMessage msg);
    public static event StructureChangedEventHandler STRUCTURE_CHANGED_EVENT;
    class StructureChangedEventHandlerClass : IUIAutomationStructureChangedEventHandler
    {
        public void HandleStructureChangedEvent(IUIAutomationElement sender, StructureChangeType changeType, int[] runtimeId)
        {
            //Logger.Log($"structureChangedEvent, senderName: {sender.CurrentName}, class: {sender.CurrentClassName}, hWnd: {sender.CurrentNativeWindowHandle}, changeType: {changeType}");
            try
            {
                StructureChangedMessage msg = new();
                msg.className = sender.CurrentClassName;
                msg.type = changeType;
                msg.name = sender.CurrentName;
                msg.hWnd = sender.CurrentNativeWindowHandle;
                msg.controlType = (ControlType)sender.CurrentControlType;
                STRUCTURE_CHANGED_EVENT(msg);
            }
            catch(Exception ex)
            {
                Logger.Log($"UIAutomation, StructureChangedEventHandler: {ex.Message}");
            }
        }
    }
    
    // frequencyAndWeights := (freq, weight)
    public delegate void AudioPlayedEventHandler(float[] amplitudes, (float, float)[] frequencyAndWeights);
    public static event AudioPlayedEventHandler AUDIO_PLAYED_EVENT = (a, fw) => { };
}

public class FocusChangedMessage
{
    public string? name;
    public string? className;
    public nint hWnd;
    public string? type;
    public ControlType controlType;
    public IUIAutomationElement? sender;
}

public class StructureChangedMessage
{
    public string? name;
    public string? className;
    public nint hWnd;
    public StructureChangeType type;
    public ControlType controlType;
}

/// <summary>
/// IUIAutomation ControlTypes
/// </summary>

public enum ControlType : int
{
    APPBAR = 50040,
    BUTTON = 50000,
    CALENDAR = 50001,
    CHECKBOX = 50002,
    COMBOBOX = 50003,
    CUSTOM = 50025,
    DATAGRID = 50028,
    DATAITEM = 50029,
    DOCUMENT = 50030,
    EDIT = 50004,
    GROUP = 50026,
    HEADER = 50034,
    HEADERITEM = 50035,
    HYPERLINK = 50005,
    IMAGE = 50006,
    LIST = 50008,
    LISTITEM = 50007,
    MENUBAR = 50010,
    MENU = 50009,
    MENUITEM = 50011,
    PANE = 50033,
    PROGRESSBAR = 50012,
    RADIOBUTTON = 50013,
    SCROLLBAR = 50014,
    SEMANTICZOOM = 50039,
    SEPARATOR = 50038,
    SLIDER = 50015,
    SPINNER = 50016,
    SPLITBUTTON = 50031,
    STATUSBAR = 50017,
    TAB = 50018,
    TABITEM = 50019,
    TABLE = 50036,
    TEXT = 50020,
    THUMB = 50027,
    TITLEBAR = 50037,
    TOOLBAR = 50021,
    TOOLTIP = 50022,
    TREE = 50023,
    TREEITEM = 50024,
    WINDOW = 50032
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\GlazeWM.cs
SIZE: 5.1 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using Newtonsoft.Json;
using System.Net.WebSockets;
using System.Text;

namespace sambar;

public partial class Api
{
	// dont initialize in fields anything that would block/hang the api instance
	// initialization, GlazeClient waits on reply, so init in separate thread or async 
	// function
	GlazeClient client;
	private async void GlazeInit()
	{
		if (Process.GetProcessesByName("glazewm").Length < 1) return;

		// The order is important, when sending subscription notification to glaze, the event 
		// handler must already be attached inorder to capture the response. We are processing 
		// this response  in GlazeEventHandler but we need all the active glaze workspaces 
		// to do so, therfore before sending the subscription run GetAllWorkspaces()
		client = new();
		client.REPLY_RECIEVED += GlazeEventHandler;
		await GetAllWorkspaces();
		await SubscribeToGlazeWMEvents();
		Logger.Log($"GlazeInit() => Workspaces: {workspaces.Count}");
	}

	public delegate void GlazeWorkspaceChangedHandler(Workspace workspace);
	public event GlazeWorkspaceChangedHandler GLAZE_WORKSPACE_CHANGED = (workspace) => { };

	public Workspace currentWorkspace = new();
	public List<Workspace> workspaces = new();

	private async Task GetAllWorkspaces()
	{
		string message = "query workspaces";
		Logger.Log("querying all workspaces");
		string reply = await client.SendCommand(message);
		Logger.Log($"SendCommand: {reply}");
		Message msg = JsonConvert.DeserializeObject<Message>(reply);
		if (msg.clientMessage == message)
		{
			int i = 0;
			foreach (Container workspace in msg.data.workspaces)
			{
				Workspace wksp = new();
				wksp.index = i;
				wksp.id = workspace.id;
				wksp.name = workspace.name;
				workspaces.Add(wksp);
				if (workspace.hasFocus == true)
				{
					currentWorkspace = wksp;
				}
				i++;
			}
		}
	}

	private void GlazeEventHandler(string message)
	{
		Logger.Log("glaze_event: " + message);
		Message msg = JsonConvert.DeserializeObject<Message>(message);
		switch (msg.messageType)
		{
			case "event_subscription":
				string focusedWorkspaceId = null;
				if (msg.data.focusedContainer.type == "window")
				{
					focusedWorkspaceId = msg.data.focusedContainer.parentId;
				}
				else if (msg.data.focusedContainer.type == "workspace")
				{
					focusedWorkspaceId = msg.data.focusedContainer.id;
				}
				currentWorkspace = workspaces.Where(wksp => wksp.id == focusedWorkspaceId).First();
				GLAZE_WORKSPACE_CHANGED(currentWorkspace);
				break;
		}
	}

	string? glazeSubscriptionId;
	private async Task SubscribeToGlazeWMEvents()
	{
		string command = $"sub --events focus_changed";
		string reply = await client.SendCommand(command);
		Logger.Log($"subscribe reply: {reply}");
		try
		{
			Message? replyMessage = JsonConvert.DeserializeObject<Message>(reply);
			glazeSubscriptionId = replyMessage?.data.subscriptionId;
			Logger.Log($"subscriptionId: {glazeSubscriptionId}");
		}
		catch (Exception ex)
		{
			Logger.Log($"[ JSON ERROR ]: {ex.Message}");
		}
	}

	internal async Task UnsubToGlazeWMEvents()
	{
		string command = $"unsub --id {glazeSubscriptionId}";
		string reply = await client.SendCommand(command);
		Logger.Log($"unsub reply: {reply}");
	}

	public async Task ChangeWorkspace(Workspace newWorkspace)
	{
		string message = $"command focus --workspace {newWorkspace.name}";
		await client.SendCommand(message);
	}

	private async void GlazeCleanup()
	{
		await UnsubToGlazeWMEvents();
	}
}

public enum GlazeCommandType
{
	QUERY, COMMAND, SUB
}

public class GlazeClient
{
	ClientWebSocket client = new();
	CancellationTokenSource cts = new();
	Uri glazeUri = new("ws://localhost:6123");
	WebSocketReceiveResult result;

	string lastReply = "";

	public delegate void ReplyRecievedHandler(string reply);
	public event ReplyRecievedHandler REPLY_RECIEVED = (msg) => { };

	public GlazeClient()
	{
		client.ConnectAsync(glazeUri, cts.Token).Wait();
		Task.Run(async () => { await ReadToBuffer(); });
	}

	async Task ReadToBuffer()
	{
		byte[] buffer = new byte[4096 * 4];
		while ((result = await client.ReceiveAsync(buffer, cts.Token)).Count > 0)
		{
			lastReply += Encoding.UTF8.GetString(buffer, 0, result.Count);
			Array.Clear(buffer);
			if (result.EndOfMessage)
			{
				if (commandMode)
				{
					commandReplyRecieved = true;
				}
				else
				{
					REPLY_RECIEVED(lastReply);
					lastReply = "";
				}
			}
		}
	}

	bool commandMode = false;
	bool commandReplyRecieved = false;
	public async Task<string> SendCommand(string command)
	{
		commandMode = true;
		commandReplyRecieved = false;
		await client.SendAsync(Encoding.UTF8.GetBytes(command), WebSocketMessageType.Text, true, cts.Token);
		while (!commandReplyRecieved)
		{
			Logger.Log("reached");
			await Task.Delay(500);
		}
		commandMode = false;
		string reply = lastReply;
		lastReply = "";
		return reply;
	}
}

public class Workspace
{
	public int index;
	public string id;
	public string name;
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\LaunchApps.cs
SIZE: 1.08 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.System;

namespace sambar;

public partial class Api {

    public async Task LaunchUri(string uri) {

        await Launcher.LaunchUriAsync(new Uri(uri));
    }

    public void StartMenu()
    {
        // nint hWnd = User32.FindWindow("Shell_TrayWnd", null);
        // dont send message to our interceptor, but the real taskbar 
        // because both have the same class
        User32.SendMessage(interceptor.originalTray_hWnd, (uint)WINDOWMESSAGE.WM_SYSCOMMAND, (nint)SYSCOMMAND.SC_TASKLIST, 0);
    }

    public void ActionCenter()
    {
        string actionCenterUri = "ms-actioncenter:controlcenter/&showFooter=true";
        LaunchUri(actionCenterUri).Wait();
    }

    public void NotificationMenu()
    {
        string notificationsMenuUri = "ms-actioncenter:controlcenter/&showFooter=true";
        LaunchUri(notificationsMenuUri ).Wait();
    }
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Menus.cs
SIZE: 5.44 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows;
using System.Windows.Interop;
using System.Windows.Controls;
using System.Diagnostics;
using System.Windows.Threading;
using Windows.ApplicationModel.VoiceCommands;

namespace sambar;
public partial class Api
{
	private void DropdownMenuInit()
	{

	}

	// internal menu tracker, so that only one menu is open at a time
	// All createmenu functions must assign to this property
	private Menu _menu;
	public Menu activeMenu
	{
		get { return _menu; }
		set
		{
			_menu?.CustomClose();
			_menu = value;
		}
	}

	// when menus that are automatically oriented relative to the calling user element
	public Menu CreateMenu(UserControl callingElement, int width = 100, int height = 100)
	{
		int x = (int)callingElement.PointToScreen(new Point(callingElement.Width / 2, callingElement.Height / 2)).X - (width / 2);
		x = x < Sambar.api.config.marginXLeft ? Sambar.api.config.marginXLeft : x;
		int y = Sambar.api.config.marginYTop + Sambar.api.config.height + 5;

		x = (int)(x / Sambar.scale);
		//y = (int)(y / Sambar.scale);

		activeMenu = new Menu(x, y, width, height);
		return activeMenu;
	}

	public Menu CreateMenu(int x, int y, int width, int height, bool centerOffset = false)
	{
		if (centerOffset)
			(x, y) = GetCenteredCoords(x, y, width, height);
		activeMenu = new Menu(x, y, width, height);
		return activeMenu;
	}

	// context menu with menubuttons
	public Menu CreateContextMenu(List<MenuButton> items)
	{
		User32.GetCursorPos(out POINT pt);
		activeMenu = new ContextMenu((int)(pt.X / Sambar.scale), (int)(pt.Y / Sambar.scale), 100, items.Count * 30);
		StackPanel panel = new();
		panel.Orientation = Orientation.Vertical;
		foreach (var item in items)
		{
			panel.Children.Add(item);
		}
		activeMenu.Content = panel;
		return activeMenu;
	}
}

public class Menu : Window
{
	nint hWnd;
	int _left, _top, _right, _bottom;
	public Menu(int x, int y, int width, int height)
	{
		this.Title = "SambarContextMenu";
		this.WindowStyle = WindowStyle.None;
		this.Topmost = true;
		this.AllowsTransparency = true;
		this.ResizeMode = ResizeMode.NoResize;
		this.Width = width;
		this.Height = height;
		this.Left = x;
		this.Top = y;
		this.ShowActivated = true;

		hWnd = new WindowInteropHelper(this).EnsureHandle();
		uint exStyles = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_EXSTYLE);
		User32.SetWindowLong(hWnd, (int)GETWINDOWLONG.GWL_EXSTYLE, (int)(exStyles | (uint)WINDOWSTYLE.WS_EX_TOOLWINDOW));
		int cornerPreference = (int)DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_ROUND;
		Dwmapi.DwmSetWindowAttribute(hWnd, DWMWINDOWATTRIBUTE.DWMWA_WINDOW_CORNER_PREFERENCE, ref cornerPreference, sizeof(int));

		_left = (int)this.Left;
		_top = (int)this.Top;
		_right = _left + (int)this.Width;
		_bottom = _top + (int)this.Height;
		Logger.Log($"Menu, L: {_left}, T: {_top}, R: {_right}, B: {_bottom}");

		Task.Run(async () =>
		{
			Sambar.api.bar.Dispatcher.Invoke(() => this.Show());
			await Task.Delay(200);
			Api.FOCUS_CHANGED_EVENT += MenuFocusChangedHandler;
		});
	}

	public bool isClosing = false;
	public virtual async void MenuFocusChangedHandler(FocusChangedMessage msg)
	{
		if (isClosing) return;

		Logger.Log($"MenuFocusChanged, name: {msg.name}, class: {msg.className}, controlType: {msg.controlType}");
		if (
			msg.name == "Desktop" ||
			msg.className == "Progman"
		)
		{
			CustomClose();
			return;
		}
		// if cursor inside menu
		User32.GetCursorPos(out POINT cursorPos);
		if (cursorPos.X > _left && cursorPos.X < _right)
			if (cursorPos.Y > _top && cursorPos.Y < _bottom)
				return;
		// Filter using ControlType
		if (
			msg.controlType == ControlType.MENU ||
			msg.controlType == ControlType.MENUITEM ||
			msg.controlType == ControlType.LIST ||
			msg.controlType == ControlType.LISTITEM ||
			msg.controlType == ControlType.BUTTON
		) return;
		//// if focus changed to itself ignore
		if (msg.name == "SambarContextMenu") return;
		if (msg.name == "Bar" && msg.className == "Window") return;
		if (Utils.IsContextMenu(msg.hWnd)) return;
		// wait for trayIconMenuChildren to get filled if icon children havent been retrieved
		// and also wait so that focus changed event is not consumed when menu it is opening
		await Task.Delay(Sambar.api!.WINDOW_CAPTURE_DURATION);
		if (!Sambar.api.capturedWindows.Select(_msg => _msg.className).Contains(msg.className))
		{
			Logger.Log($"Closing menu by losing focus to non-menu item: {msg.name}, {msg.className}");
			CustomClose();
		}
	}

	public void CustomShow()
	{
		Sambar.api?.bar.Dispatcher.Invoke(() => this.Show());
	}
	public void CustomClose()
	{
		isClosing = true;
		Sambar.api?.bar.Dispatcher.Invoke(() => this.Close());
	}
}

public class ContextMenu : Menu
{
	public ContextMenu(int x, int y, int width, int height) : base(x, y, width, height)
	{
	}

	public override async void MenuFocusChangedHandler(FocusChangedMessage msg)
	{
		if (isClosing) return;

		if (msg.name != "SambarContextMenu") Sambar.api.bar.Dispatcher.Invoke(() => CustomClose());
		Logger.Log($"overriden focushandler, closing due to: {msg.name}");
	}
}

public class MenuButton : RoundedButton
{
	public MenuButton(string text)
	{
		Text = text;
		HoverEffect = true;
		Margin = new(5);
		CornerRadius = new(5);
		HoverColor = Utils.BrushFromHex("#383838");
		Height = 20;
		FontFamily = new("JetBrains Mono");
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\System.cs
SIZE: 3.84 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Animation;

namespace sambar;

public partial class Api
{
	IActiveDesktop activeDesktop;

	public void SystemInit()
	{
		Type? activeDesktopClass = Type.GetTypeFromCLSID(CLSID.ActiveDesktop);
		activeDesktop = (IActiveDesktop)Activator.CreateInstance(activeDesktopClass);
		Logger.Log($"ad_class_null: {activeDesktopClass == null}, ad_null: {activeDesktop == null}");
	}

	public string GetWallpaper()
	{
		StringBuilder str = new(512);
		activeDesktop?.GetWallpaper(str, str.Capacity, (int)AD_GETWP.IMAGE);
		Logger.Log($"the wallpaper is {str.ToString()}");
		return str.ToString();
	}

	public void SetWallpaper(string imageFile)
	{
		int? res = activeDesktop?.SetWallpaper(imageFile, 0 /* dwReserved = 0 */);
		Logger.Log($"Setting Wallpaper: {imageFile}, res: {res}, iadnull: {activeDesktop == null}");
		activeDesktop?.ApplyChanges(AD_Apply.ALL);
	}

	public void SetWallpaper(string imageFile, WallpaperAnimation animation, int duration = 2)
	{
		Window? wnd = Sambar.api?.CreateDesktopOverlay();
		wnd!.Background = new SolidColorBrush(System.Windows.Media.Colors.Transparent);
		Canvas canvas = new();

		Image img = new() { Source = GetImageSource(imageFile) };
		//Image img2 = new() { Source = new BitmapImage(new Uri(@"C:\Users\Jayakuttan\Pictures\Wallpapers\1360350.png")) };

		Utils.ScaleImage(img, (int)wnd.Width, (int)wnd.Height);
		//Utils.ScaleImage(img2, (int)wnd.Width, (int)wnd.Height);

		double final_radius = Math.Max(wnd.Width, wnd.Height);
		final_radius += 0.25 * final_radius;

		double radiusX_initial = 0, radiusX_final = final_radius;
		double radiusY_initial = 0, radiusY_final = final_radius;

		EllipseGeometry ellipse = new(new Point(0, 0), radiusX_initial, radiusY_initial);
		// register a name for the ellipse so it can be targetted for animations
		NameScope.SetNameScope(wnd, new NameScope());
		string ellipseName = "ellipse";
		wnd!.RegisterName(ellipseName, ellipse);

		GeometryDrawing geometryDrawing = new() { Geometry = ellipse, Brush = new SolidColorBrush(Colors.Black) };

		//https://stackoverflow.com/questions/14283528/positioning-an-opacitymask-in-wpf
		DrawingBrush drawingBrush = new()
		{
			Drawing = geometryDrawing,
			Stretch = Stretch.None,
			ViewboxUnits = BrushMappingMode.Absolute,
			AlignmentX = AlignmentX.Left,
			AlignmentY = AlignmentY.Top
		};

		img.OpacityMask = drawingBrush;

		// Animation
		DoubleAnimation doubleAnimationX = new()
		{
			From = radiusX_initial,
			To = radiusX_final,
			Duration = TimeSpan.FromSeconds(duration),
			AutoReverse = false
		};
		DoubleAnimation doubleAnimationY = new()
		{
			From = radiusX_initial,
			To = radiusY_final,
			Duration = TimeSpan.FromSeconds(duration),
			AutoReverse = false
		};
		Storyboard storyboard = new();

		Storyboard.SetTargetName(doubleAnimationX, ellipseName);
		Storyboard.SetTargetProperty(doubleAnimationX, new PropertyPath(EllipseGeometry.RadiusXProperty));

		Storyboard.SetTargetName(doubleAnimationY, ellipseName);
		Storyboard.SetTargetProperty(doubleAnimationY, new PropertyPath(EllipseGeometry.RadiusYProperty));

		storyboard.Children.Add(doubleAnimationX);
		storyboard.Children.Add(doubleAnimationY);

		// triggers animation at window load
		wnd.Loaded += (s, e) => { storyboard.Begin(wnd); };
		canvas.Children.Add(img);

		// close the window once animation is complete and wallpaper is set
		storyboard.Completed += (s, e) =>
		{
			SetWallpaper(imageFile);
			wnd.Close();
		};

		//
		wnd!.Content = canvas;
		wnd.Show();
	}
}

public enum WallpaperAnimation
{
	CORNER_BLOOM,
	NONE
}





================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\SystemTray.cs
SIZE: 7.15 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Interop;
using System.Windows.Media.Imaging;
using System.Windows.Media.TextFormatting;
using Interop.UIAutomationClient;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Win32;

namespace sambar;

public partial class Api {

    private List<TrayIcon> trayIcons = new();
    private RegistryKey trayIconsRegistryKeyRoot;
    private List<TrayIconRegKey> UIOrderListRegKeys = new();

    // Constructor
    private void SystemTrayInit()
    {
        // for trayIcon's images
        trayIconsRegistryKeyRoot = Registry.CurrentUser.OpenSubKey("Control Panel").OpenSubKey("NotifyIconSettings");
        byte[] raw_UIOrderList = (byte[])trayIconsRegistryKeyRoot.GetValue("UIOrderList");
        string fullHex = Convert.ToHexStringLower(raw_UIOrderList);
        Logger.Log($"UIOrderList: {fullHex}");
        fullHex.Chunk(16).ToList().ForEach(chunk => {
            string hex = new(chunk);
            char[][] chunks = hex.Chunk(2).ToArray();
            chunks = chunks.Reverse().ToArray();
            string reverse = "";
            chunks.ToList().ForEach(_c => reverse += new string(_c));
            ulong num = (ulong)Int64.Parse(reverse, System.Globalization.NumberStyles.HexNumber);
            //Logger.Log($"chunk: {hex}, reverse: {reverse}, decimal: {num}");
            TrayIconRegKey key = new();
            key.parentKey = $"{num}";
            key.ExecutablePath = (string)trayIconsRegistryKeyRoot.OpenSubKey($"{num}").GetValue("ExecutablePath");
            key.IconGuid = (string)trayIconsRegistryKeyRoot.OpenSubKey($"{num}").GetValue("IconGuid");
            key.IconSnapshot = (byte[])trayIconsRegistryKeyRoot.OpenSubKey($"{num}").GetValue("IconSnapshot");
            key.UID = unchecked((uint?)(int?)trayIconsRegistryKeyRoot.OpenSubKey($"{num}").GetValue("UID"));
            UIOrderListRegKeys.Add(key);
            Logger.Log($"{num}, {key.ExecutablePath}");
        });

        Process[] runningProcesses = Process.GetProcesses();
        runningProcesses.ToList().ForEach(p => Logger.Log("executable path: " + p.ProcessName));
        List<string> trayProcesses = new();
        // filter out the non running ones
        UIOrderListRegKeys = UIOrderListRegKeys
            .Where(
                key => runningProcesses
                        .Select(_p => _p.ProcessName)
                        .ToList()
                        .Contains(key.ExecutablePath
                                        .Split(@"\")
                                        .Last()
                                        .Replace(".exe", "")
            ))
            .ToList();


        //trayIconRegKeys.ForEach(item => Logger.Log($"running: {item.ExecutablePath}"));

        // from these use either IconGuid or hWnd + UID to figure out which is in overflow
        // tray by Shell_NotifyIconGetRect()
        /*
        List<GUIProcess> allWindows = Utils.EnumWindowProcesses();
        List<TrayIconRegKey> actuallyInTrayRegKeys = new();
        foreach(var key in UIOrderListRegKeys)
        {
            _NOTIFYICONIDENTIFIER identifier = new();
            identifier.cbSize = (uint)Marshal.SizeOf<_NOTIFYICONIDENTIFIER>();
            long result;    
            // IconGuid exists
            if(key.IconGuid != null)
            {
                Logger.Log($"{key.ExecutablePath}, IconGuid, parent: {key.parentKey}");
                identifier.guidItem = new(key.IconGuid);
                if((result = Shell32.Shell_NotifyIconGetRect(ref identifier, out RECT iconLocation)) != 0) 
                {
                    Logger.Log($"failed: {result}");
                }
                if (
                    iconLocation.Left != 0 ||
                    iconLocation.Top != 0 ||
                    iconLocation.Right != 0 ||
                    iconLocation.Bottom != 0
                ) actuallyInTrayRegKeys.Add(key);
            }
            // UID + hWnd
            else if(key.UID != null)
            {
                identifier.UID = (uint)key.UID;
                string exePath = key.ExecutablePath;
                string processName = exePath.Split(@"\").Last().Replace(".exe", "");
                if (processName == "Taskmgr") identifier.UID = 0;
                var process = runningProcesses.Where(_p => _p.ProcessName == processName).First();
                GUIProcess guiProcess = allWindows.Where(gui_p => gui_p.name == process.ProcessName).First();
                foreach (var window in guiProcess.windows)
                {
                    identifier.hWnd = window.hWnd;
                    if((result = Shell32.Shell_NotifyIconGetRect(ref identifier, out RECT iconLocation)) != 0) 
                    {
                        Logger.Log($"failed: {result}");
                    }
                    if (
                        iconLocation.Left != 0 ||
                        iconLocation.Top != 0 ||
                        iconLocation.Right != 0 ||
                        iconLocation.Bottom != 0
                    )
                    {
                        actuallyInTrayRegKeys.Add(key);
                        break;
                    }
                }
                //nint hWnd = Utils.GetHWNDFromPID(process.Id);
                Logger.Log($"{key.ExecutablePath}, UID: {key.UID}, handle: {identifier.hWnd}, parent: {key.parentKey}");
            }
            else
            {
                Logger.Log($"BOTH NULL, path: {key.ExecutablePath}, UID: {key.UID}, parent: {key.parentKey}");
            }
        }

        actuallyInTrayRegKeys.ForEach(key => Logger.Log("regInTrayFound: " + key.ExecutablePath));
        */
        // Enumerate TrayOverflowMenu
        //IntPtr hWnd_Overflow = User32.FindWindow("TopLevelWindowForOverflowXamlIsland", null);
        //IntPtr hWnd_IconContainer = User32.FindWindowEx(hWnd_Overflow, IntPtr.Zero, "Windows.UI.Composition.DesktopWindowContentBridge", null);

        //var innerIconContainer = ui.ElementFromHandle(hWnd_IconContainer);
        //var icons = innerIconContainer.FindAll(TreeScope.TreeScope_Children, ui.CreateTrueCondition());
        //
        //for(int i = 0; i < icons.Length; i++) {
        //    var icon = icons.GetElement(i);
        //    TrayIcon trayIcon = new(i, hWnd_Overflow, icon as IUIAutomationElement3);
        //    trayIcon.szTip = icon.CurrentName;
        //    trayIcons.Add(trayIcon);
        //}

        //trayIcons.ForEach(icon => Logger.Log($"trayIcon, {icon.element.FindAll(TreeScope.TreeScope_Children, ui.CreateTrueCondition()).GetElement(0).CurrentClassName}") );
        
        
        // icons obtained through registry enumeration must be same as that obtained
        // from IUIAutomation
        //Trace.Assert(actuallyInTrayRegKeys.Count == icons.Length);


    }

   
}


public class TrayIconRegKey
{
    public string parentKey;
    public string ExecutablePath;
    public string IconGuid;
    public byte[] IconSnapshot;
    public uint? UID;
}






================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Taskbar.cs
SIZE: 15.23 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Drawing;
using System.Windows.Media.Imaging;
using System.Windows.Interop;
using System.Windows;

namespace sambar;

public partial class Api
{
	TaskbarInterceptor interceptor;

	public void TaskbarInterceptorInit()
	{
		interceptor = new();
	}
	Dictionary<ICONACTION, List<WINDOWMESSAGE>> ICONACTION_MAP_V0_3 = new()
	{
		{ ICONACTION.RIGHT_CLICK, [ WINDOWMESSAGE.WM_RBUTTONDOWN, WINDOWMESSAGE.WM_RBUTTONUP ] },
		{ ICONACTION.LEFT_CLICK, [ WINDOWMESSAGE.WM_LBUTTONDOWN, WINDOWMESSAGE.WM_LBUTTONUP ] },
	};
	Dictionary<ICONACTION, List<WINDOWMESSAGE>> ICONACTION_MAP_V3 = new()
	{
		{ ICONACTION.RIGHT_CLICK, [ WINDOWMESSAGE.WM_CONTEXTMENU ] },
		{ ICONACTION.LEFT_CLICK, [ WINDOWMESSAGE.WM_LBUTTONDOWN, WINDOWMESSAGE.WM_LBUTTONUP ] },
	};

	/// <summary>
	/// tray icons are registered on the taskbar by their respective windows inorder for them
	/// to be shown in the taskbar, upon being registered each icon has a callback message which the 
	/// taskbar uses to communicate events back to the icon's hidden backing window. These
	/// events include things like requesting the context menu when right clicked, or opening the 
	/// main ui of the tray app when clicked so on and so forth all of which has to be supplied by
	/// the icon's backing (message processing) window. Therefore interacting with the icon is 
	/// equivalent to sending/impersonating this callback communication from the taskbar to the 
	/// backing window.
	/// </summary>
	/// <param name="nid"></param>
	/// <param name="msg"></param>
	public void ImpersonateTrayEvent(NOTIFYICONDATA nid, ICONACTION msg)
	{
		User32.GetWindowThreadProcessId((nint)nid.hWnd, out uint processId);
		int result = User32.AllowSetForegroundWindow(processId);
		Logger.Log($"ImpersonateTrayEvent(): {processId}, result: {result}, win32: {Marshal.GetLastWin32Error()}");
		if (nid.uTimeoutOrVersion.uVersion <= 3)
		{
			foreach (var winmsg in ICONACTION_MAP_V0_3[msg])
			{
				// For some reason this SendMessage call can hang for certain applications
				// such as Taskmgr (hWnd), therefore run it in a separate thread to prevent
				// the mainwindow from crashing 
				Action _send = () => User32.SendMessage(
					(nint)nid.hWnd,
					nid.uCallbackMessage,
					(nint)nid.uID,
					Utils.MAKELPARAM((short)winmsg, 0)
				);
				Task.Run(_send);
			}
		}
		else
		{
			foreach (var winmsg in ICONACTION_MAP_V3[msg])
			{
				User32.GetCursorPos(out POINT cursorPos);
				Action _send = () => User32.SendMessage(
					(nint)nid.hWnd,
					nid.uCallbackMessage,
					Utils.MAKEWPARAM((short)cursorPos.X, (short)cursorPos.Y),
					Utils.MAKELPARAM((short)winmsg, (short)nid.uID)
				);
				Task.Run(_send);
			}
		}
	}
	public List<TrayIcon> GetTrayIcons()
	{
		var icons = interceptor.trayIconsManager.GetTrayIcons();
		Logger.Log($"GetTrayIcons(): {icons.Count()}");
		return icons;
	}

	public delegate void TaskbarChangedEventHandler();
	public event TaskbarChangedEventHandler TASKBAR_CHANGED = () => { };
	public static void TaskbarChanged()
	{
		Sambar.api?.TASKBAR_CHANGED();
	}
}
/// <summary>
/// An invisible window to intercept(or listen to) taskbar messages.
/// We create a window with the preexisting Taskbar class
/// "Shell_TrayWnd". Any messages intended for the real taskbar
/// will be captured by our invisible window
/// </summary>
public class TaskbarInterceptor
{
	nint hWnd;
	public nint originalTray_hWnd;
	CancellationTokenSource cts;
	public TaskbarInterceptor()
	{
		// capture the original taskbar hWnd before creating the interceptor window
		// with the same class name so as to forward messages to it. why is this necessary ?
		// well its not just for wanting to use the original taskbar alongside sambar but also
		// in instances where for example certain context menus are natively created by the taskbar
		// and not by the actual tray icon application
		originalTray_hWnd = User32.FindWindow("Shell_TrayWnd", null);
		cts = new();
		Task.Run(() =>
		{
			WNDCLASSEX wc = new();
			wc.cbSize = (uint)Marshal.SizeOf<WNDCLASSEX>();
			wc.lpfnWndProc = WndProc;
			// run GetModuleHandle() in the same thread as CreateWindowEx()
			wc.hInstance = Kernel32.GetModuleHandle(null);
			wc.lpszClassName = "Shell_TrayWnd";

			ushort result = User32.RegisterClassEx(ref wc);
			if (result == 0)
			{
				Logger.Log($"RegisterClassEx() failed: {Marshal.GetLastWin32Error()}");
			}
			else
			{
				Logger.Log($"RegisterClassEx() success !");
			}

			hWnd = User32.CreateWindowEx(
				WINDOWSTYLE.WS_EX_TOPMOST | WINDOWSTYLE.WS_EX_TOOLWINDOW,
				wc.lpszClassName,
				null,
				WINDOWSTYLE.WS_POPUP | WINDOWSTYLE.WS_CLIPCHILDREN | WINDOWSTYLE.WS_CLIPSIBLINGS,
				0,
				0,
				0,
				0,
				nint.Zero,
				nint.Zero,
				nint.Zero,
				nint.Zero
			);

			// Set window as topmost first and set a timer that keeps on doing just that
			if (User32.SetWindowPos(hWnd, (nint)(-1), 0, 0, 0, 0, SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOACTIVATE) == 0)
			{
				Logger.Log($"SetWindowPos() failed: {Marshal.GetLastWin32Error()}");
			}

			User32.SetTimer(hWnd, 1, 100, null);

			RefreshTaskbar();

			while (User32.GetMessage(out MSG msg, hWnd, 0, 0) > 0)
			{
				User32.TranslateMessage(ref msg);
				User32.DispatchMessage(ref msg);
			}
		}, cts.Token);
	}

	public TrayIconsManager trayIconsManager = new();
	//public List<TrayIcon> overflowIcons = new();


	/// <summary>
	/// WndProc for our taskbar interceptor
	/// </summary>
	/// <returns>
	/// Data specific to the Window Message it recieves.
	/// The return code is sent to whoever sents the window a window message.
	/// </returns>
	nint WndProc(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam)
	{
		//Logger.Log($"Message: {uMsg}");
		switch (uMsg)
		{
			case WINDOWMESSAGE.WM_CLOSE:
				User32.DestroyWindow(hWnd);
				break;
			case WINDOWMESSAGE.WM_DESTROY:
				User32.PostQuitMessage(0);
				break;
			case WINDOWMESSAGE.WM_TIMER:
				User32.SetWindowPos(hWnd, (nint)(-1), 0, 0, 0, 0, SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOACTIVATE);
				break;
			case WINDOWMESSAGE.WM_COPYDATA:
				COPYDATASTRUCT copydata = Marshal.PtrToStructure<COPYDATASTRUCT>(lParam);
				if (copydata.cbData == 0) return 0;
				switch ((SHELLTRAYMESSAGE)copydata.dwData)
				{
					case SHELLTRAYMESSAGE.ICONUPDATE:
						SHELLTRAYICONUPDATEDATA iconData = Marshal.PtrToStructure<SHELLTRAYICONUPDATEDATA>(copydata.lpData);
						NOTIFYICONDATA nid = iconData.nid;
						switch ((ICONUPDATEACTION)iconData.dwMessage)
						{
							case ICONUPDATEACTION.NIM_ADD:
								trayIconsManager.Add(nid);
								break;
							case ICONUPDATEACTION.NIM_MODIFY:
							case ICONUPDATEACTION.NIM_SETVERSION:
								trayIconsManager.Update(nid);
								break;
							case ICONUPDATEACTION.NIM_DELETE:
								trayIconsManager.Delete(nid);
								break;
						}
						// for api.TASKBAR_CHANGED event
						// Api.TaskbarChanged();
						Logger.Log($"ICONUPDATEACTION: {(ICONUPDATEACTION)(iconData.dwMessage)}, uid: {nid.uID}, hWnd: {nid.hWnd}, nids: {trayIconsManager.icons.Count}, class: {Utils.GetClassNameFromHWND((nint)nid.hWnd)}, version: {nid.uTimeoutOrVersion.uVersion}, callback: {nid.uCallbackMessage}, hIcon: {nid.hIcon}");
						break;

					// a tray icon's process is querying icon position using Shell_NotifyIconGetRect()
					// windows can only communicate by returning data through their WndProcs, so
					// assemble the data here and return it below. Certain tray apps for example glazewm
					// queries Shell_NotifyIconGetRect() right before displaying its trayicon's context
					// menu probably to get the icon coordinates for some reason, so handling it is imoportant
					case SHELLTRAYMESSAGE.TRAYICONPOSITION:
						_NOTIFYICONIDENTIFIERINTERNAL iconIdentifier = Marshal.PtrToStructure<_NOTIFYICONIDENTIFIERINTERNAL>(copydata.lpData);
						User32.GetCursorPos(out POINT cursorPos);
						switch (iconIdentifier.msg)
						{
							// request for left, top positions of the icon rect, case 1
							case 1:
								return Utils.MAKELPARAM((short)cursorPos.X, (short)cursorPos.Y);
							// request for the right, bottom of the icon rect
							case 2:
								return Utils.MAKELPARAM((short)(cursorPos.X + 1), (short)(cursorPos.Y - 1));
						}
						return 0;
				}
				break;
			default:
				User32.SendMessage(originalTray_hWnd, (uint)uMsg, wParam, lParam);
				return User32.DefWindowProc(hWnd, uMsg, wParam, lParam);
		}
		return 0;
	}

	/// <summary>
	/// Send taskbar created notification so that apps that are already on the taskbar
	/// can tell us who they are and their icon infos. This is essential to enumerate
	/// taskbar icons.
	/// </summary>
	public void RefreshTaskbar()
	{
		uint taskbarCreatedMsg = User32.RegisterWindowMessage("TaskbarCreated");
		const nint HWND_BROADCAST = 0xffff;
		User32.SendNotifyMessage(HWND_BROADCAST, taskbarCreatedMsg, 0, 0);
	}

	public void Destroy()
	{
		User32.DestroyWindow(hWnd);
		cts.Cancel();
	}
	~TaskbarInterceptor()
	{
		Destroy();
	}
}

// TODO: use IUIAutomation for Windows Defender Context Menu
public class TrayIcon
{
	public NOTIFYICONDATA nid;
	public string? className;
	public string? exePath;
	public uint old_uVersion;
	public uint processId;
	public BitmapSource icon;

	public TrayIcon(NOTIFYICONDATA nid)
	{
		this.nid = nid;
		this.className = Utils.GetClassNameFromHWND((nint)nid.hWnd);
		this.exePath = Utils.GetExePathFromHWND((nint)nid.hWnd);

		// could fail for all kinds of reasons since nid is essentially something
		// given to us and we have no control over it, for eq nid.hIcon could be null
		try
		{
			User32.GetWindowThreadProcessId((nint)nid.hWnd, out processId);
			// get actual icon from hIcon
			this.icon = Imaging.CreateBitmapSourceFromHIcon((nint)nid.hIcon, Int32Rect.Empty, BitmapSizeOptions.FromEmptyOptions());
			this.icon.Freeze();
		}
		catch (Exception ex) { Logger.Log(ex.Message); }
	}

	public NOTIFYICONDATA ValidateNid(NOTIFYICONDATA nid)
	{
		NOTIFYICONDATA validatedNid = nid;

		// validate uVersion. If uVersion is exorbitantly large that means that it probably 
		// isnt uVersion but uTimeout
		if (validatedNid.uTimeoutOrVersion.uVersion > 4)
		{
			old_uVersion = nid.uTimeoutOrVersion.uVersion;
			validatedNid.uTimeoutOrVersion.uVersion = 0;
		}

		// check if uCallbackMessage is still invalid, for most user applications it wont be, but
		// for certain system tray apps it could, if so use uid as callback message
		// eg. SystemTray_Main
		if (
			validatedNid.uCallbackMessage == 0 &&
			!validatedNid.uFlags.ContainsFlag((uint)NOTIFYICONDATAVALIDITY.NIF_MESSAGE)
		)
		{
			validatedNid.uCallbackMessage = nid.uID;
		}

		// handling special classes
		// [ATL:00007FFE197FD000] SecurityHealthSystray.exe
		if (this.className == "ATL:00007FFE197FD000")
		{
			validatedNid.uTimeoutOrVersion.uVersion = 4;
		}

		return validatedNid;
	}

	public void ContextMenu()
	{
		NOTIFYICONDATA validatedNid = ValidateNid(nid);
		//RightClick, class: tray_icon_app, exe: C:\Program Files\glzr.io\GlazeWM\glazewm.exe, hWnd: 3802056, uVersion: 0, callback: 6002 
		Logger.Log($"RightClick, class: {className}, exe: {exePath}, hWnd: {validatedNid.hWnd}, uid: {validatedNid.uID}, uVersion: {validatedNid.uTimeoutOrVersion.uVersion}, callback: {validatedNid.uCallbackMessage}, callbackValid: {(validatedNid.uFlags & 0x00000001) != 0},  old_uid: {old_uVersion}");
		Sambar.api.ImpersonateTrayEvent(validatedNid, ICONACTION.RIGHT_CLICK);
	}

	public void Click()
	{
		NOTIFYICONDATA validatedNid = ValidateNid(nid);
		Logger.Log($"LeftClick, class: {className}, exe: {exePath}, hWnd: {validatedNid.hWnd}, uid: {validatedNid.uID}, uVersion: {validatedNid.uTimeoutOrVersion.uVersion}, callback: {validatedNid.uCallbackMessage}, callbackValid: {(validatedNid.uFlags & 0x00000001) != 0},  old_uid: {old_uVersion}");
		Sambar.api.ImpersonateTrayEvent(validatedNid, ICONACTION.LEFT_CLICK);
	}
}

/// <summary>
/// Adds nids to notifiedIcons so that it doesnt contain repeated elements and newer nids 
/// of already present tray icons when recieved are only added while removing the older one. 
/// However additional care has to be taken while adding newer nids because certain apps such
/// as Taskmgr for example wont have a valid uCallbackMessage when sending subsequent nids through
/// NIM_MODIFY, so we dont want to add the nid directly as then we would lose our uCallbackMessage
/// </summary>
public class TrayIconsManager
{
	public List<TrayIcon> icons = new();
	public TrayIconsManager()
	{
		MonitorTrayApps();
	}

	public void Add(NOTIFYICONDATA nid)
	{
		var indexedIcons = icons.Index().ToList();
		var repIndexedIcons = indexedIcons.Where(indexedIcon => indexedIcon.Item.nid.hWnd == nid.hWnd);
		if (repIndexedIcons.Count() == 0)
		{
			icons.Add(new(nid));
			Api.TaskbarChanged();
			return;
		}
		Logger.Log($"icon already exists, use Update() to modify");
	}
	public void Update(NOTIFYICONDATA nid)
	{
		var indexedIcons = icons.Index().ToList();
		var repIndexedIcons = indexedIcons.Where(indexedIcon => indexedIcon.Item.nid.hWnd == nid.hWnd);
		if (repIndexedIcons.Count() > 0)
		{
			// if new nids contain invalid uCallbackMessage replace them with the old ones
			if (nid.uCallbackMessage == 0)
			{
				nid.uCallbackMessage = repIndexedIcons.First().Item.nid.uCallbackMessage;
			}
			// if new nids contain invalid hIcon replace them with old ones
			if (!nid.uFlags.ContainsFlag((int)NOTIFYICONDATAVALIDITY.NIF_ICON))
			{
				nid.hIcon = repIndexedIcons.First().Item.nid.hIcon;
			}

			icons[repIndexedIcons.First().Index] = new(nid);
			Api.TaskbarChanged();
			return;
		}
		Logger.Log($"icon does not exist, use Add() instead");
	}
	public void Delete(NOTIFYICONDATA nid)
	{
		var indexedIcons = icons.Index().ToList();
		var foundIcons = indexedIcons.Where(icon => icon.Item.nid.hWnd == nid.hWnd).ToList();
		if (foundIcons.Count() == 0) return;
		var foundIcon = foundIcons.First();
		icons.RemoveAt(foundIcon.Index);
		Api.TaskbarChanged();
	}
	List<string> NON_OVERFLOW_CLASSES =
	[
		"ATL:00007FFE3066B050", // SPEAKER
        "BluetoothNotificationAreaIconWindowClass",
		"ASYNCUI_NOTIFYICON_WINDOW_CLASS"
	];
	public List<TrayIcon> GetTrayIcons()
	{
		return icons.Where(icon => !NON_OVERFLOW_CLASSES.Contains(icon.className)).ToList();
	}

	CancellationTokenSource cts = new();
	/// <summary>
	/// Because some tray apps simply dont emit NIM_DELETE
	/// when terminated
	/// </summary>
	public void MonitorTrayApps()
	{
		Task.Run(async () =>
		{
			while (true)
			{
				var icons = GetTrayIcons();
				foreach (var icon in icons)
				{
					// check if trayicon app is running (has pid != 0 and matches the icon's pid)
					User32.GetWindowThreadProcessId((nint)icon.nid.hWnd, out uint _pid);
					if (icon.processId != _pid) Delete(icon.nid);
				}
				await Task.Delay(500);
			}
		}, cts.Token);
	}

	~TrayIconsManager()
	{
		cts.Cancel();
	}
}

public enum ICONACTION
{
	RIGHT_CLICK,
	LEFT_CLICK,
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\ToggleTaskbar.cs
SIZE: 1.34 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Drawing;
using System.Diagnostics;

namespace sambar;

public partial class Api
{

	// Constructor
	public void ToggleTaskbarInit()
	{
		taskbar_hWnd = User32.FindWindow("Shell_TrayWnd", null);
		WINDOWPLACEMENT lpwndpl = new();
		User32.GetWindowPlacement(taskbar_hWnd, ref lpwndpl);
		Logger.Log($"ToggleTaskBarInit: {lpwndpl.showCmd}");
	}

	nint taskbar_hWnd;
	public bool taskbarVisible = true;
	public void ToggleTaskbar()
	{
		if (taskbar_hWnd == 0) return;
		if (taskbarVisible)
		{
			HideTaskbar();
		}
		else
		{
			ShowTaskbar();
		}
	}

	public void HideTaskbar()
	{
		SetTaskbarState(APPBARSTATE.AutoHide);
		User32.ShowWindow(taskbar_hWnd, SHOWWINDOW.SW_HIDE);
		taskbarVisible = false;
	}

	public void ShowTaskbar()
	{
		SetTaskbarState(APPBARSTATE.AlwaysOnTop);
		User32.ShowWindow(taskbar_hWnd, SHOWWINDOW.SW_SHOW);
		taskbarVisible = true;
	}

	private void SetTaskbarState(APPBARSTATE state)
	{
		APPBARDATA msgData = new();
		msgData.cbSize = (uint)Marshal.SizeOf<APPBARDATA>();
		msgData.hWnd = taskbar_hWnd;
		msgData.lParam = (uint)state;
		Shell32.SHAppBarMessage((uint)APPBARMESSAGE.SetState, ref msgData);
	}

	private void ToggleTaskbarCleanup()
	{
		// TODO
	}
}





================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\Utilities.cs
SIZE: 0.35 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows.Media.Imaging;

namespace sambar;

/// <summary>
/// Some common utilities and ease of life functions to use
/// </summary>
public partial class Api
{
	public BitmapImage GetImageSource(string imageFile)
	{
		return new BitmapImage(new Uri(imageFile));
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\WindowCatcher.cs
SIZE: 0.86 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;

namespace sambar;

public partial class Api
{
    public void WindowCatcherInit()
    {
        STRUCTURE_CHANGED_EVENT += CaptureWindows;
    }

    private bool capturing = false;
    public List<StructureChangedMessage> capturedWindows = new();
    public int WINDOW_CAPTURE_DURATION = 50;
    public async void StartTimedWindowCapture()
    { 
        capturing = true;
        capturedWindows = new();
        await Task.Delay(WINDOW_CAPTURE_DURATION);
        capturing = false;
    }
    private void CaptureWindows(StructureChangedMessage msg)
    {
        //Logger.Log($"StructureChanged, name: {msg.name}, class: {msg.className}, type: {msg.controlType}");
        if (capturing)
        {
            capturedWindows.Add(msg);
        }
    }
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Api\WindowTracker.cs
SIZE: 4.18 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Text;
using System.Windows;
using System.Windows.Interop;
using System.Windows.Media.Imaging;

namespace sambar;
public partial class Api
{
	/// <summary>
	/// Tracks active windows and exposes events
	/// that fire when focus is changed 
	/// </summary>

	public delegate void ActiveWindowChangedHandler(RunningApp app);
	/// <summary>
	/// subscribe to this event to recieve active window
	/// changed messages
	/// </summary>
	public event ActiveWindowChangedHandler ACTIVE_WINDOW_CHANGED_EVENT = (app) => { };

	public void WindowingInit()
	{
		FOCUS_CHANGED_EVENT += WindowFocusChangedHandler;
		MonitorTaskbarApps();
	}

	List<RunningApp> runningApps = new();
	public void RefreshRunningApps()
	{
		List<nint>? hWndsInTaskbar = Utils.GetAllTaskbarWindows();
		// since instantiating a RunningApp loads everything including the icon
		// and refreshing runs very fast, we only instantiate new apps

		// add new (if any)
		if (hWndsInTaskbar == null) return;
		foreach (nint hWnd in hWndsInTaskbar)
		{
			if (!runningApps.Select(app => app.hWnd).Contains(hWnd))
			{
				runningApps.Add(new(hWnd));
			}
		}
		// remove apps not in hWndsInTaskbar
		runningApps = runningApps.Where(app => hWndsInTaskbar.Contains(app.hWnd)).ToList();
	}

	public void WindowFocusChangedHandler(FocusChangedMessage msg)
	{
		// we dont use IUIAutomation's hWnd because it returns elements inner to native windows
		// which most often do not have a native win32 handle
		nint foreground_hWnd = User32.GetForegroundWindow();
		//Logger.Log($"FOCUS CHANGED, foreground_hWnd: {foreground_hWnd}, foreground_className: {Utils.GetClassNameFromHWND(foreground_hWnd)}");

		// refresh running apps every time to account for newer windows
		List<RunningApp>? apps = new();
		if ((apps = runningApps?.Where(app => app.hWnd == foreground_hWnd).ToList()).Count() > 0)
		{
			ACTIVE_WINDOW_CHANGED_EVENT(apps.First());
			//Logger.Log($"ACTIVE WINDOW CHANGED: {apps.First().title}");
		}
	}

	public delegate void TaskbarAppsEventHandler(List<RunningApp> apps);
	public event TaskbarAppsEventHandler TASKBAR_APPS_EVENT = (apps) => { };
	CancellationTokenSource _mta_cts = new();
	/// <summary>
	/// Live task for constantly monitoring current taskbar apps
	/// </summary>
	List<RunningApp> _old_runningApps = new();
	bool updateRequired = false;
	public void MonitorTaskbarApps()
	{
		Task.Run(async () =>
		{
			while (true)
			{
				RefreshRunningApps();
				// wpf ui rendering is expensive, therefore only fire when new apps actually 
				// have appeared
				if (runningApps != null && runningApps.Count != _old_runningApps.Count || updateRequired)
				{
					//Logger.Log("MONITOR APPS TRUE", file: false);
					TASKBAR_APPS_EVENT(runningApps);
					_old_runningApps = runningApps.ToList();
				}
				//Logger.Log($"MONITORING TASKBAR APPS: {runningApps.Count}, {_old_runningApps.Count}", file: false);
				await Task.Delay(100);
			}
		}, _mta_cts.Token);
	}

	public async void FlushEvents()
	{
		updateRequired = true;
		await Task.Delay(200);
		updateRequired = false;
	}
}

public class RunningApp
{
	public nint hWnd;
	public string title;
	public string exePath;
	public string className;
	public uint processId;
	public BitmapSource icon;

	public RunningApp(nint hWnd)
	{
		this.hWnd = hWnd;
		StringBuilder str = new(256);
		User32.GetWindowText(hWnd, str, str.Capacity);
		title = str.ToString();
		exePath = Utils.GetExePathFromHWND(hWnd)!;
		className = Utils.GetClassNameFromHWND(hWnd);
		User32.GetWindowThreadProcessId(hWnd, out processId);

		Shell32.ExtractIconEx(exePath, 0, out nint largeIcon, out nint smallIcon, 1);
		if (largeIcon != 0)
		{
			icon = Imaging.CreateBitmapSourceFromHIcon(largeIcon, Int32Rect.Empty, BitmapSizeOptions.FromEmptyOptions());
			icon.Freeze();
		}
	}

	public void FocusWindow()
	{
		Logger.Log($"App requested focus");
		User32.SetForegroundWindow(hWnd);
	}
	public void Kill()
	{
		//Process.GetProcessById((int)processId).Kill();
		User32.SendMessage(hWnd, (uint)WINDOWMESSAGE.WM_CLOSE, 0, 0);
	}
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Com\CLSID.cs
SIZE: 0.2 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

namespace sambar;

public class CLSID
{
	public static readonly Guid ActiveDesktop = new("75048700-EF1F-11D0-9888-006097DEACF9");
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Com\Enums.cs
SIZE: 1.29 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

namespace sambar;

public enum WallPaperStyle : int
{
	WPSTYLE_CENTER = 0,
	WPSTYLE_TILE = 1,
	WPSTYLE_STRETCH = 2,
	WPSTYLE_MAX = 3
}

[Flags]
public enum AD_Apply : int
{
	SAVE = 0x00000001,
	HTMLGEN = 0x00000002,
	REFRESH = 0x00000004,
	ALL = SAVE | HTMLGEN | REFRESH,
	FORCE = 0x00000008,
	BUFFERED_REFRESH = 0x00000010,
	DYNAMICREFRESH = 0x00000020
}

[Flags]
public enum ComponentModify : int
{
	TYPE = 0x00000001,
	CHECKED = 0x00000002,
	DIRTY = 0x00000004,
	NOSCROLL = 0x00000008,
	POS_LEFT = 0x00000010,
	POS_TOP = 0x00000020,
	SIZE_WIDTH = 0x00000040,
	SIZE_HEIGHT = 0x00000080,
	POS_ZINDEX = 0x00000100,
	SOURCE = 0x00000200,
	FRIENDLYNAME = 0x00000400,
	SUBSCRIBEDURL = 0x00000800,
	ORIGINAL_CSI = 0x00001000,
	RESTORED_CSI = 0x00002000,
	CURITEMSTATE = 0x00004000,
	ALL = TYPE | CHECKED | DIRTY | NOSCROLL | POS_LEFT | SIZE_WIDTH |
			  SIZE_HEIGHT | POS_ZINDEX | SOURCE |
			  FRIENDLYNAME | POS_TOP | SUBSCRIBEDURL | ORIGINAL_CSI |
			  RESTORED_CSI | CURITEMSTATE
}

public enum DtiAddUI : int
{
	DEFAULT = 0x00000000,
	DISPSUBWIZARD = 0x00000001,
	POSITIONITEM = 0x00000002,
}

public enum AD_GETWP : uint
{
	BMP = 0x00000000,
	IMAGE = 0x00000001,
	LAST_APPLIED = 0x00000002
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Com\Interfaces.cs
SIZE: 1.17 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;

namespace sambar;

// shlobj_core.h
[ComImport]
[Guid("f490eb00-1240-11d1-9888-006097deacf9")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface IActiveDesktop
{
	[PreserveSig]
	int ApplyChanges(AD_Apply dwFlags);
	[PreserveSig]
	int GetWallpaper([MarshalAs(UnmanagedType.LPWStr)] System.Text.StringBuilder pwszWallpaper,
		  int cchWallpaper,
		  int dwReserved);
	[PreserveSig]
	int SetWallpaper([MarshalAs(UnmanagedType.LPWStr)] string pwszWallpaper, int dwReserved);
	[PreserveSig]
	int GetWallpaperOptions(ref WALLPAPEROPT pwpo, int dwReserved);
	[PreserveSig]
	int SetWallpaperOptions(ref WALLPAPEROPT pwpo, int dwReserved);
	[PreserveSig]
	int GetPattern([MarshalAs(UnmanagedType.LPWStr)] System.Text.StringBuilder pwszPattern, int cchPattern, int dwReserved);
	[PreserveSig]
	int SetPattern([MarshalAs(UnmanagedType.LPWStr)] string pwszPattern, int dwReserved);
	[PreserveSig]
	int GetDesktopItemOptions(ref COMPONENTSOPT pco, int dwReserved);
	[PreserveSig]
	int SetDesktopItemOptions(ref COMPONENTSOPT pco, int dwReserved);
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Com\Structs.cs
SIZE: 0.62 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;

namespace sambar;

[StructLayout(LayoutKind.Sequential)]
public struct WALLPAPEROPT
{
	public static readonly int SizeOf = Marshal.SizeOf(typeof(WALLPAPEROPT));
	public int dwSize;
	public WallPaperStyle dwStyle;
}

[StructLayout(LayoutKind.Sequential)]
public struct COMPONENTSOPT
{
	public static readonly int SizeOf = Marshal.SizeOf(typeof(COMPONENTSOPT));
	public int dwSize;
	[MarshalAs(UnmanagedType.Bool)]
	public bool fEnableComponents;
	[MarshalAs(UnmanagedType.Bool)]
	public bool fActiveDesktop;
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Config\Config.cs
SIZE: 1.68 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using Newtonsoft.Json;

namespace sambar;

public class Config
{
	public int height = 40;
	public int width = 0;
	public int marginXLeft = 10;
	public int marginXRight = 10;
	public int marginYTop = 10;
	public int paddingXLeft = 0;
	public int paddingXRight = 0;
	public int paddingYTop = 0;
	public int paddingYDown = 0;
	public string backgroundColor = "";
	public bool roundedCorners = true;
	public string borderColor = "";
	public int borderThickness = 0;
	public string widgetPack = "Base";

	[JsonConstructor]
	public Config(
		int? height,
		int? width,
		int? marginXLeft,
		int? marginXRight,
		int? marginYTop,
		int? paddingXLeft,
		int? paddingXRight,
		int? paddingYTop,
		int? paddingYDown,
		string? backgroundColor,
		bool? roundedCorners,
		string? borderColor,
		int? borderThickness,
		string? widgetPack
	) {

		this.height = height ?? 40;
		this.width = width ?? 0;
		this.marginXLeft = marginXLeft ?? 10;
		this.marginXRight = marginXRight ?? 10;
		this.marginYTop = marginYTop ?? 10;
		this.paddingXLeft = paddingXLeft ?? 0;
		this.paddingXRight = paddingXRight ?? 0;
		this.paddingYTop = paddingYTop ?? 0;
		this.paddingYDown = paddingYDown ?? 0;
		this.backgroundColor = backgroundColor ?? "#ffffff";
		this.borderColor = borderColor ?? "#ffffff";
		this.borderThickness = borderThickness ?? 0;
		this.widgetPack = widgetPack ?? "Base";
	}

	public Config(int screenWidth) {
		width = screenWidth - (marginXLeft + marginXRight);	
	}

	public Config() { }
}

// .imports.cs
public class WidgetImports
{
	public string importsPack;
	public List<string> widgets;
}





================================================================================
FILE: :\DEV\sambar\Src\Classes\Config\Layout.cs
SIZE: 0.66 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows.Controls;
using System.Reflection;

namespace sambar;

public class Layout
{
    public Panel Container;
    public Dictionary<string, Border> WidgetToContainerMap = new();
    public Layout()
    {
        this.GetType()
            .GetFields(BindingFlags.NonPublic | BindingFlags.Instance)
            .ToList()
            .Where(fieldInfo => fieldInfo.FieldType == typeof(Border))
            .ToList()
            .ForEach(fieldInfo =>
            {
                WidgetToContainerMap[fieldInfo.Name] = (Border)fieldInfo.GetValue(this);
            });
    }
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Config\Paths.cs
SIZE: 1.24 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.IO;
using System.Reflection;

namespace sambar;

public class Paths
{
#if DEBUG
	public static readonly string rootFolder = Directory.GetCurrentDirectory();
#else
	public static readonly string rootFolder = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!;
#endif
	public static readonly string widgetPacksFolder = Path.Join(rootFolder, "WidgetPacks");
	public static readonly string initCsFile = Path.Join(widgetPacksFolder, ".init.cs");
	public static readonly string dllFolder = Path.Join(rootFolder, "_.dll");
	public static readonly string configDll = Path.Join(dllFolder, ".config.dll");
	public static readonly string hashesFile = Path.Join(dllFolder, "hashes.json");
	public static readonly string logFile = Path.Join(rootFolder, "sambar.log");

	// need to be set by once widgetPack is determined 
	public static string assetsFolder
	{
		get
		{
			return Path.Combine(widgetPacksFolder, Sambar.api!.bar.widgetPackName, "assets");
		}
	}

	internal static void CreateIfAbsent()
	{
		if (!File.Exists(widgetPacksFolder)) Directory.CreateDirectory(widgetPacksFolder);
		if (!File.Exists(dllFolder)) Directory.CreateDirectory(dllFolder);
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Engine\Widget.cs
SIZE: 0.75 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.IO;

namespace sambar;

public class Widget : Border
{
	public int index;

	public UIElement Content
	{
		get { return this.Child; }
		set { this.Child = value; }
	}

	public Dispatcher Thread
	{
		get { return this.Dispatcher; }
	}

	Config config;
	public WidgetEnv ENV;
	protected Widget(WidgetEnv ENV)
	{
		this.HorizontalAlignment = HorizontalAlignment.Left;
		config = Sambar.api.config;

		this.ENV = ENV;
	}
}

public class WidgetEnv
{
	public string ASSETS_FOLDER;
	public string HOME = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Engine\WidgetEngine.cs
SIZE: 12.18 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using System.Reflection;
using System.IO;
using System.Windows.Controls;
using System.Diagnostics;
using System.Windows.Media;
using System.Windows;
using System.Windows.Ink;
using System.Windows.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Emit;
using Newtonsoft.Json;
using System.Runtime.Loader;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Net.Http;
using Windows.UI.Composition;
using ScottPlot.WPF;
using SkiaSharp;
using SkiaSharp.Views.WPF;
using SkiaSharp.Views.Desktop;

namespace sambar;

internal class WidgetLoader
{
	public List<Widget> widgets = new();

	Dictionary<string, string> widgetToDllMap = new();

	WidgetImports? imports = null;
	public WidgetLoader()
	{
		string? widgetPackName = Sambar.api?.bar.widgetPackName;

		var files = new DirectoryInfo(Path.Join(Paths.widgetPacksFolder, widgetPackName)).GetFiles();
		var widgetFiles = files.Where(file => file.Name.EndsWith(".widget.cs")).ToList();
		var cachedDlls = new DirectoryInfo(Paths.dllFolder).GetFiles();

		// read imports file and add widgets if any
		string importsFile = Path.Join(Paths.widgetPacksFolder, widgetPackName, ".imports.cs");
		if (Path.Exists(importsFile))
		{
			imports = GetObjectFromScript<WidgetImports>(importsFile);
			if (!Directory.Exists(Path.Join(Paths.widgetPacksFolder, imports?.importsPack))) throw new Exception($"{imports?.importsPack} does not exist");
			imports?.widgets.ForEach(_widget => widgetFiles.Add(new(Path.Join(Paths.widgetPacksFolder, imports.importsPack, _widget + ".widget.cs"))));
		}

		Logger.Log(imports == null ? "No .imports.cs file found!" : $".imports.cs, pack: {imports.importsPack}");

		// verify hashes and figure out which widgets to compile		
		List<FileInfo> widgetFilesToCompile = new();
		if (!File.Exists(Paths.hashesFile))
		{
			BuildWidgetHistory(widgetFiles);
			widgetFilesToCompile = new(widgetFiles);
		}
		else
		{
			widgetToHash = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(File.ReadAllText(Paths.hashesFile));
			widgetFiles
				.ForEach(
				file =>
				{
					string hash = ComputeWidgetSriptHash(File.ReadAllText(file.FullName));

					// new script added
					if (!widgetToHash.ContainsKey(file.Name))
					{
						widgetFilesToCompile.Add(file);
					}
					else if (widgetToHash[file.Name] != hash)
					{
						widgetFilesToCompile.Add(file);
					}
				});
		}

		// add script to compile list if dll is missing
		widgetFiles.ForEach(file =>
		{
			string widgetName = file.Name.Replace(".widget.cs", "");
			widgetToDllMap[widgetName] = Path.Join(Paths.dllFolder, widgetName + ".widget.dll");
			if (!cachedDlls.Select(dll => dll.Name).ToList().Contains(file.Name.Replace(".cs", ".dll")))
			{
				widgetFilesToCompile.Add(file);
			}
		});

		Logger.Log($"To compile: {widgetFilesToCompile.Count()}");
		widgetFilesToCompile.ForEach(file => Logger.Log($"name: {file.Name}"));

		var themesFile = files.Where(file => file.Name == ".theme.cs").FirstOrDefault();
		string? widgetsPrefix = null;
		//bool compileWithThemes = false;
		if (themesFile != null)
		{
			//compileWithThemes = true;
			//widgetsPrefix = File.ReadAllText(themesFile.FullName);
			Utils.CompileFileToDll(themesFile.FullName, ".theme");
		}

		var layoutFile = files.Where(file => file.Name == ".layout.cs").FirstOrDefault();
		if (layoutFile == null) throw new Exception($".layout.cs missing in {widgetPackName}");
		Utils.CompileFileToDll(layoutFile.FullName, ".layout");

		var layoutAssembly = Assembly.LoadFile(Path.Join(Paths.dllFolder, ".layout.dll"));
		Type layoutType = layoutAssembly.GetTypes().Where(type => type.IsSubclassOf(typeof(Layout))).First();
		Layout layout = (Layout)Activator.CreateInstance(layoutType);

		// IMPORTANT
		Sambar.api!.bar.Content = layout?.Container;

		widgetFilesToCompile
			.ForEach(
				file =>
				{
					Logger.Log($"Compiling {file.Name}");
					string fileContent = File.ReadAllText(file.FullName);
					//string finalScript = widgetsPrefix + "\n" + fileContent;
					string dllName = file.Name.Replace(".cs", "");
					Utils.CompileStringToDll(fileContent, $"{dllName}", [(Path.Join(Paths.dllFolder, ".theme.dll"), null)]);
					widgetToDllMap[file.Name.Replace(".widget.cs", "")] = Path.Join(Paths.dllFolder, dllName + ".dll");
				}
			);

		// update hashes after compilation (if any)
		BuildWidgetHistory(widgetFiles);

		Logger.Log("Loading compiled dlls...");
		// add _.dll to dependency search path so that if widgets contain dependency dlls
		// such as .theme.dll they are loaded
		AssemblyLoadContext.Default.Resolving += (assemblyLoadContext, name) =>
		{
			string _assemblyPath = Path.Join(Paths.dllFolder, name.Name);
			if (File.Exists(_assemblyPath)) return Assembly.LoadFrom(_assemblyPath);
			return null;
		};
		foreach (var widgetName in widgetToDllMap)
		{
			var assembly = Assembly.LoadFile(widgetName.Value);
			Type[] typesInAssembly = assembly.GetTypes();
			Type widgetType = typesInAssembly.Where(type => type.IsSubclassOf(typeof(Widget))).First();
			// prepare the ENV VARS for widget
			WidgetEnv env = PrepareEnvVarsForWidget(widgetName.Key);
			Widget widget = (Widget)Activator.CreateInstance(widgetType, [env])!; // where the widget actually runs
			if (widget != null) { widgets.Add(widget); }
		}

		// widgets currently being loaded
		Logger.Log($"[ Currently loaded widgets: {widgets.Count} ]");
		Logger.Log(widgets.Select(widget => widget.Name).ToList());

		widgets.ForEach(
			widget =>
			{
				//layout.WidgetToContainerMap[widget.GetType().Name].Child = widget;
				Border? border = layout?.WidgetToContainerMap.GetValueOrDefault(widget.GetType().Name);
				if (border != null) border.Child = widget;
			}
		);

		GC.Collect();
	}

	/// <summary>
	/// compiles code (primarily classes) into dlls. Used to compile widgets, themes, layouts etc
	/// Since assembly cache is not unloaded automatically this must be run on a separate thread
	/// and discarded, so use the wrapper defined inside Utils
	/// </summary>
	/// <param name="classCode"></param>
	/// <param name="dllName"></param>
	/// <param name="additionalDllsAndUsings"></param>
	public static void CompileToDll(string classCode, string dllName, List<(string, string?)>? additionalDllsAndUsings = null)
	{
		List<MetadataReference> references =
		[
			MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Object).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Sambar).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Debug).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Thread).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Task).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(List<>).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Application).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(UIElement).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Control).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Brush).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(JsonConvert).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Enum).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(DependencyObject).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Uri).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(HttpClient).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(DrawingAttributes).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(WpfPlot).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(ScottPlot.Colors).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(System.Drawing.Color).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(ScottPlot.Plottables.Signal).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(SKSurface).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(SKElement).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(SKPaintSurfaceEventArgs).Assembly.Location),
			MetadataReference.CreateFromFile(Assembly.Load("System.Runtime").Location),
			MetadataReference.CreateFromFile(Assembly.Load("System.Collections").Location),
		];

		string usingsPrefix =
"""
using sambar;
using System;
using System.IO;
using System.Linq;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Input;
using System.Windows.Controls;
using System.Windows.Media;
using System.Net.Http;
using System.Windows.Ink;
using Newtonsoft.Json;
using ScottPlot.WPF;
using ScottColors = ScottPlot.Colors;
using ScottPlot.Plottables;
using SkiaSharp;
using SkiaSharp.Views.WPF;
""";

		if (additionalDllsAndUsings != null)
		{
			additionalDllsAndUsings
				.ForEach(dllAndUsing =>
				{
					references.Add(MetadataReference.CreateFromFile(dllAndUsing.Item1));
					if (dllAndUsing.Item2 != null) usingsPrefix += "\n" + $"using {dllAndUsing.Item2}";
				}
			);
		}

		string code = usingsPrefix + classCode;
		CSharpParseOptions parseOptions = new(LanguageVersion.Preview);
		SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(code, parseOptions);
		CSharpCompilationOptions compilationOptions = new(OutputKind.DynamicallyLinkedLibrary);

		CSharpCompilation compilation = CSharpCompilation.Create(
			$"{dllName}.dll",
			[syntaxTree],
			references,
			compilationOptions
		);

		using var ms = new MemoryStream();
		var result = compilation.Emit(ms);

		if (!result.Success)
		{
			Logger.Log($"COMPILATION FAILED: {dllName}");
			foreach (Diagnostic err in result.Diagnostics)
			{
				Logger.Log(err.GetMessage());
			}
		}
		ms.Seek(0, SeekOrigin.Begin);
		var assembly = Assembly.Load(ms.ToArray());
		File.WriteAllBytes(Path.Join(Paths.dllFolder, $"{dllName}.dll"), ms.ToArray());
		Logger.Log("Types found: " + assembly.GetTypes().First().Name);
	}

	public string ComputeWidgetSriptHash(string widgetCode)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(widgetCode);
		MD5 md5 = MD5.Create();
		return Convert.ToHexStringLower(md5.ComputeHash(bytes));
	}

	Dictionary<string, string> widgetToHash = new();
	public void BuildWidgetHistory(List<FileInfo> widgetFiles)
	{
		if (File.Exists(Paths.hashesFile)) { File.Delete(Paths.hashesFile); }
		foreach (var file in widgetFiles)
		{
			string content = File.ReadAllText(file.FullName);
			string hash = ComputeWidgetSriptHash(content);
			widgetToHash[file.Name] = hash;
		}
		string historyFile = System.Text.Json.JsonSerializer.Serialize(widgetToHash);
		File.WriteAllTextAsync(Paths.hashesFile, historyFile);
	}

	/// <summary>
	/// Evaluate Script
	/// (Alternative to CompileDll)
	/// </summary>
	public static T? GetObjectFromScript<T>(string scriptPath)
	{
		if (!File.Exists(scriptPath))
		{
			Logger.Log($"{scriptPath} does not exist, exiting...");
			return default(T);
		}
		string script = File.ReadAllText(scriptPath);
		ScriptOptions options = ScriptOptions.Default
								.AddReferences(typeof(Sambar).Assembly)
								.WithImports("sambar");
		T? obj = default(T);
		Thread _t = new(async () =>
		{
			try
			{
				obj = await CSharpScript.EvaluateAsync<T>(script, options: options);
			}
			catch (Exception ex)
			{
				Logger.Log($"unable to compile {scriptPath}");
				Logger.Log(ex.Message);
			}
		});
		_t.Start();
		_t.Join();
		return obj;
	}

	public WidgetEnv PrepareEnvVarsForWidget(string widgetName)
	{
		WidgetEnv env = new();
		if (imports == null)
		{
			env.ASSETS_FOLDER = Path.Join(Paths.widgetPacksFolder, Sambar.api!.bar.widgetPackName, "assets");
		}
		if (imports!.widgets.Contains(widgetName))
		{
			env.ASSETS_FOLDER = Path.Join(Paths.widgetPacksFolder, imports.importsPack, "assets");
		}
		return env;
	}

}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Hooks\minhook\hooker.cs
SIZE: 2 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System;
using System.Runtime.InteropServices;

enum MH_STATUS : int
{
	MH_UNKNOWN = -1,
	MH_OK = 0,
	MH_ERROR_ALREADY_INITIALIZED,
	MH_ERROR_NOT_INITIALIZED,
	MH_ERROR_ALREADY_CREATED,
	MH_ERROR_NOT_CREATED,
	MH_ERROR_ENABLED,
	MH_ERROR_DISABLED,
	MH_ERROR_NOT_EXECUTABLE,
	MH_ERROR_UNSUPPORTED_FUNCTION,
	MH_ERROR_MEMORY_ALLOC,
	MH_ERROR_MEMORY_PROTECT,
	MH_ERROR_MODULE_NOT_FOUND,
	MH_ERROR_FUNCTION_NOT_FOUND
}

class Hooker
{

	[DllImport("Minhook.x64.dll", SetLastError = true)]
	static extern MH_STATUS MH_Initialize();
	[DllImport("Minhook.x64.dll", SetLastError = true)]
	static extern MH_STATUS MH_CreateHook(nint pTarget, nint pDetour, nint ppOriginal);
	[DllImport("Minhook.x64.dll", SetLastError = true)]
	static extern MH_STATUS MH_EnableHook(nint ptarget);

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint LoadLibrary(string module);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint GetProcAddress(nint dllBase, string procName);
	[DllImport("user32.dll", SetLastError = true)]
	static extern int MessageBoxA(nint hWnd, string text, string caption, uint type);

	static void HandleError(MH_STATUS code)
	{
		if (code != MH_STATUS.MH_OK)
		{
			throw new Exception($"MinHook Error: {code}");
		}
	}

	delegate int MessageBoxA_Delegate(nint hWnd, nint lpText, nint lpCaption, uint uType);
	static int MessageBoxA_Hook(nint hWnd, nint lpText, nint lpCaption, uint uType)
	{
		Console.WriteLine("No message box for you !");
		return 0;
	}

	[UnmanagedCallersOnly(EntryPoint = "Hook")]
	public static void Hook()
	{

		nint user32Base = (nint)LoadLibrary("user32.dll");
		nint targetFnPtr = GetProcAddress(user32Base, "MessageBoxA");
		nint hookFnPtr = Marshal.GetFunctionPointerForDelegate<MessageBoxA_Delegate>(MessageBoxA_Hook);

		HandleError(MH_Initialize());
		HandleError(MH_CreateHook(targetFnPtr, hookFnPtr, 0));
		HandleError(MH_EnableHook(0));

		MessageBoxA(0, "hello", "message", (uint)0x00000000L);
	}
}





================================================================================
FILE: :\DEV\sambar\Src\Classes\Hooks\minhook\hookerInjector.cs
SIZE: 5.63 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.ComponentModel;

#nullable enable

class HookerInjector
{
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint OpenProcess(uint dwDesiredAccess, bool bInheritHandles, uint dwProcessId);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern int CloseHandle(nint handle);
	[DllImport("psapi.dll", SetLastError = true)]
	static extern int GetModuleFileNameExA(nint hProcess, nint hModule, StringBuilder str, int nSize);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint GetProcAddress(nint hModule, string procName);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint LoadLibraryA(string moduleName);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint CreateRemoteThread(
		nint hProcess,
		nint securityAttributes,
		nuint dwStackSize,
		nint localFn,
		nint fnArgs,
		uint dwCreationFlags,
		out uint threadId
	);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint VirtualAllocEx(
		nint hProcess,
		nint lpAddress,
		nuint dwSize,
		uint allocationType,
		uint protect
	);
	[DllImport("kernel32.dll", SetLastError = true)]
	static extern int WriteProcessMemory(
		nint hProcess,
		nint baseAddress,
		nint buffer,
		nuint size,
		nint bytesWritten
	);

	[DllImport("psapi.dll", SetLastError = true)]
	static extern int EnumProcessModulesEx(nint hProcess, [Out] nint ptrToModuleArray, int moduleArrayLength, [Out] nint sizeNeeded, uint flags);

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern int WaitForSingleObject(nint hHandle, uint dwMilliseconds);

	static unsafe Dictionary<string, nint>? GetModulesInProcess(nint hProcess)
	{
		int initArrayLength = 1024;
		nint* modules = stackalloc nint[initArrayLength];
		int cb = initArrayLength * sizeof(nint);
		uint sizeNeeded = 0;
		uint LIST_MODULES_ALL = 0x03;
		if (EnumProcessModulesEx(hProcess, (nint)modules, cb, (nint)(&sizeNeeded), LIST_MODULES_ALL) > 0)
		{
			Dictionary<string, nint> dlls = new();
			for (int i = 0; i < sizeNeeded / sizeof(nint); i++)
			{
				StringBuilder str = new(1024);
				if (GetModuleFileNameExA(hProcess, modules[i], str, str.Capacity) > 0)
				{
					dlls[str.ToString()] = modules[i];
				}
			}
			Console.WriteLine("printing dlls...");
			for (int i = 0; i < dlls.Count; i++)
			{
				Console.WriteLine($"{i}: {dlls.ElementAt(i).Key}");
			}
			return dlls;
		}
		Console.WriteLine($"EnumProcessModules() failed, win32: {Marshal.GetLastWin32Error()}");
		return null;


	}

	static nint FindModuleInProcess(nint hProcess, string moduleName)
	{
		var modules = GetModulesInProcess(hProcess);
		var module = modules.First(pair => pair.Key.ToLower().Contains(moduleName));
		return module.Value;
	}

	static nint GetRVAOfProcInModule(string moduleName, string procName)
	{
		nint dllBase = LoadLibraryA($"{moduleName}.dll");
		return GetProcAddress(dllBase, procName) - dllBase;
	}

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern bool GetExitCodeThread(nint hThread, out uint exitCode);

	static void CallFunctionInProcess(nint hProcess, nint fnAddressInProcess, nint fnArgsInProcess)
	{
		nint remoteThread = 0;
		if ((remoteThread = CreateRemoteThread(hProcess, 0, 0, fnAddressInProcess, fnArgsInProcess, 0, out uint threadId)) == 0)
		{
			throw new Win32Exception(Marshal.GetLastWin32Error());
		}
		Console.WriteLine($"remoteThread: {remoteThread}");
		int exitReason = WaitForSingleObject(remoteThread, 5000);
		GetExitCodeThread(remoteThread, out uint exitCode);
		Console.WriteLine($"exitReason: {exitReason}, threadReturn: {exitCode}");
	}

	static unsafe void Inject()
	{
		Console.Write("processId: ");
		uint processId = Convert.ToUInt32(Console.ReadLine());
		const uint PROCESS_ALL_ACCESS = 0x1FFFFF;
		nint hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, processId);
		Console.WriteLine($"hProcess: {hProcess}");
		//CloseHandle(hProcess);

		// 1. call target's kernerl32!LoadLibrary with argument "hooker.dll"
		nint kernel32Base = FindModuleInProcess(hProcess, "kernel32");
		Console.WriteLine($"kernel32base: {kernel32Base}");
		nint loadLibraryRva = GetRVAOfProcInModule("kernel32", "LoadLibraryW");
		Console.WriteLine($"loadLibraryRva: {loadLibraryRva}");

		string hookerDllPath = new FileInfo("hooker.dll").FullName + "\0";
		Console.WriteLine($"hookerDllPath: {hookerDllPath}");
		byte[] data = Encoding.Unicode.GetBytes(hookerDllPath);
		const uint MEM_RESERVE = 0x00002000;
		const uint MEM_COMMIT = 0x00001000;
		const uint PAGE_READWRITE = 0x04;
		nint argPtr = VirtualAllocEx(hProcess, 0, (nuint)data.Length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		Console.WriteLine($"argPtr: {argPtr}");

		fixed (void* dataPtr = data)
		{
			if (WriteProcessMemory(hProcess, argPtr, (nint)dataPtr, (nuint)data.Length, 0) == 0)
			{
				throw new Win32Exception(Marshal.GetLastWin32Error());
			}
		}

		Console.WriteLine("calling loadlibrary in target ...");
		CallFunctionInProcess(hProcess, kernel32Base + loadLibraryRva, argPtr);
		GetModulesInProcess(hProcess);
		nint hookerBase = FindModuleInProcess(hProcess, "hooker");
		Console.WriteLine($"hookerBase: {hookerBase}");
		nint fnHookRva = GetRVAOfProcInModule("hooker", "Hook");
		Console.WriteLine($"fnHookRva: {fnHookRva}");
		nint fnHook = hookerBase + fnHookRva;
		CallFunctionInProcess(hProcess, fnHook, 0);
		// check if hooker.dll is loaded in target
		// 2. call hooker's Hook() function
	}

	static void Main()
	{
		Inject();
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Hooks\minhook\target.cs
SIZE: 0.26 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

class Target
{
	public static void Main()
	{
		Console.WriteLine("blocking...");
		Console.WriteLine($"processId: {Process.GetCurrentProcess().Id}");
		Console.ReadKey();
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Sambar.cs
SIZE: 3.88 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Net.WebSockets;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using System.Diagnostics;
using System.IO;
using Newtonsoft.Json;
using System.Drawing;
using System.ComponentModel;
using System.Windows.Forms;

namespace sambar;

/// <summary>
/// Interaction logic for MainWindow.xaml
/// </summary>
public partial class Sambar : Window
{
	public nint hWnd;
	public static Api? api;
	Config config;
	public string widgetPackName;
	bool firstShow = true;
	internal Sambar(string widgetPackName, Config config)
	{
		// Initialize the following in order
		// 1. window 
		// 2. api
		// 3. widgets

		this.Title = "Bar";
		this.WindowStyle = WindowStyle.None;
		this.AllowsTransparency = true;
		this.Topmost = true;
		this.widgetPackName = widgetPackName;
		this.config = config;

		// WPF event sequence
		// https://memories3615.wordpress.com/2017/03/24/wpf-window-events-sequence/
		SourceInitialized += (s, e) =>
		{
			hWnd = new WindowInteropHelper(this).Handle;
			WindowInit(); // needs hWnd
		};

		Activated += (s, e) =>
		{
			if (firstShow)
			{
				api = new(this);
				api.config = config; //setting a copy of the config to the API 
				AddWidgets();
				firstShow = false;
			}
		};
	}

	public static double scale;
	bool barTransparent = false;
	public static int screenWidth;
	public static int screenHeight;
	public void WindowInit()
	{
		screenWidth = User32.GetSystemMetrics(0);
		screenHeight = User32.GetSystemMetrics(1);

		// get the scalefactor of the primary monitor
		scale = Utils.GetDisplayScaling();
		Logger.Log($"Scale factor: {scale}");
		screenWidth = (int)(screenWidth / scale);
		screenHeight = (int)(screenHeight / scale);

		if (config.width == 0) { config.width = screenWidth - (config.marginXLeft + config.marginXRight); }

		this.Background = Utils.BrushFromHex(config.backgroundColor);
		if (this.Background.Equals(Colors.Transparent)) { barTransparent = true; }

		// Make bar a toolwindow (appear always on top)
		// TODO: loses topmost to other windows when task manager is open
		uint exStyles = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_EXSTYLE);
		User32.SetWindowLong(hWnd, (int)GETWINDOWLONG.GWL_EXSTYLE, (int)(exStyles | (uint)sambar.WINDOWSTYLE.WS_EX_TOOLWINDOW));

		Utils.HideWindowInAltTab(hWnd);

		//Win32.SetWindowPos(hWnd, IntPtr.Zero, config.marginXLeft, config.marginYTop, config.width, config.height, 0x0400);
		this.Width = config.width;
		this.Height = config.height;
		this.Left = config.marginXLeft;
		this.Top = config.marginYTop;

		Logger.Log($"this.Width: {config.width}");

		int cornerPreference = (int)DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_ROUND;
		if (!barTransparent && config.roundedCorners)
			Dwmapi.DwmSetWindowAttribute(hWnd, DWMWINDOWATTRIBUTE.DWMWA_WINDOW_CORNER_PREFERENCE, ref cornerPreference, sizeof(int));

		// bar right click context menu
		this.SetContextMenu([
			("Exit", (s, e) => { Exit(); }),
		]);
	}

	public async void AddWidgets()
	{
		// the api has some blocking init tasks (looking at you glazewm) in the constructor that widgets might request, so only load the widgets once they are finished
		await Task.WhenAll(api!.initTasks);
		WidgetLoader widgetLoader = new();
		// since the api starts much earlier than the widgets, fire events to update state once
		// widgets are loaded
		Sambar.api.FlushEvents();
	}

	// cleanup and exit
	public void Exit()
	{
		Sambar.api?.Cleanup();
		_Main.app.Shutdown();
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Schemas\GlazeSchemas.cs
SIZE: 4.03 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

// GlazeWM Reply Schemas

public class BorderDelta
{
	public Left left { get; set; }
	public Top top { get; set; }
	public Right right { get; set; }
	public Bottom bottom { get; set; }
	public BorderDelta() { }
}

public class Bottom
{
	public double amount { get; set; }
	public string unit { get; set; }
	public Bottom() { }
}
public class Left
{
	public double amount { get; set; }
	public string unit { get; set; }
	public Left() { }
}

public class Right
{
	public double amount { get; set; }
	public string unit { get; set; }
	public Right() { }
}

public class State
{
	public string type { get; set; }
	public State() { }
}

public class PrevState
{
	public string type { get; set; }
	public bool? centered { get; set; }
	public bool? shownOnTop { get; set; }
	public PrevState() { }
}

public class Top
{
	public double amount { get; set; }
	public string unit { get; set; }
	public Top() { }
}

public class FloatingPlacement
{
	public int left { get; set; }
	public int top { get; set; }
	public int right { get; set; }
	public int bottom { get; set; }
	public FloatingPlacement() { }
}

public class Container
{
	public string? type { get; set; }
	public string? id { get; set; }
	public string? name { get; set; }
	public string? parentId { get; set; }
	public bool? hasFocus { get; set; }
	public double? tilingSize { get; set; }
	public int? width { get; set; }
	public int? height { get; set; }
	public int? x { get; set; }
	public int? y { get; set; }
	public State? state { get; set; }
	public object? prevState { get; set; }
	public string? displayState { get; set; }
	public bool? isDisplayed { get; set; }
	public BorderDelta? borderDelta { get; set; }
	public FloatingPlacement? floatingPlacement { get; set; }
	public int? handle { get; set; }
	public string? title { get; set; }
	public string? className { get; set; }
	public string? processName { get; set; }
	public object? activeDrag { get; set; }
	public List<Container>? children { get; set; }
	public List<string>? childFocusOrder { get; set; }
	public string? tilingDirection { get; set; }
	public Container() { }
}

public class Data
{
	public string eventType { get; set; }
	public string subscriptionId { get; set; }
	public Container focusedContainer { get; set; }
	public List<Container> workspaces { get; set; }
	public Data() { }
}

/* Responses
 * ---------
 * */

public class Message
{
	public string messageType { get; set; }
	public string clientMessage { get; set; }
	public Data data { get; set; }
	public string? error { get; set; }
	public string? subscriptionId { get; set; }
	public bool success { get; set; }
	public Message() { }
}

/* SUBSCRIPTIONS
 * -------------
 * query: sub -e focus_changed
 * {"messageType":"client_response","clientMessage":"sub -e focus_changed","data":{"subscriptionId":"3a454bb1-baf2-4372-a6f8-872e27031cd9"},"error":null,"success":true}
 *
 * query: unsub --id {subscriptionId}
 * {"messageType":"client_response","clientMessage":"unsub --id 3a454bb1-baf2-4372-a6f8-872e27031cd9","data":null,"error":null,"success":true}
 *
 * EVENTS
 * ------
 * event: focus_changed
 * {"messageType":"event_subscription","data":{"eventType":"focus_changed","focusedContainer":{"type":"window","id":"ea59a01c-0032-43b2-95f9-2fb6b724959e","parentId":"cc84580a-7290-4186-a7e3-d86b6a5e4f54","hasFocus":true,"tilingSize":1.0,"width":1346,"height":748,"x":10,"y":10,"state":{"type":"tiling"},"prevState":null,"displayState":"hidden","borderDelta":{"left":{"amount":0.0,"unit":"pixel"},"top":{"amount":0.0,"unit":"pixel"},"right":{"amount":0.0,"unit":"pixel"},"bottom":{"amount":0.0,"unit":"pixel"}},"floatingPlacement":{"left":78,"top":48,"right":1289,"bottom":721},"handle":37946962,"title":"glazewm-go/command/client-messages.go at 9034d5a7debd13b518255dcb87e5ce331a43b7d1 Â· burgr033/glazewm-go â€” Mercury","className":"MozillaWindowClass","processName":"mercury","activeDrag":null}},"error":null,"subscriptionId":"3a454bb1-baf2-4372-a6f8-872e27031cd9","success":true}
 *
 *
 * */



================================================================================
FILE: :\DEV\sambar\Src\Classes\Ui\ItemSelector.cs
SIZE: 0.08 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

namespace sambar;





================================================================================
FILE: :\DEV\sambar\Src\Classes\Ui\RoundedButton.cs
SIZE: 5.01 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Drawing;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using SharpVectors;
using SharpVectors.Converters;
using Brush = System.Windows.Media.Brush;
using Image = System.Windows.Controls.Image;

namespace sambar;

public class RoundedButton : UserControl
{
	public string Id;
	Border RoundedButtonBorder = new();
	TextBlock RoundedButtonTextBlock = new();
	Image RoundedButtonImage = new();
	BitmapImage bi = new();
	SvgViewbox RoundedButtonSvgImage = new();
	public string Text
	{
		get { return this.RoundedButtonTextBlock.Text; }
		set
		{
			this.RoundedButtonTextBlock.Text = value;
			this.RoundedButtonBorder.Child = RoundedButtonTextBlock;
		}
	}

	private string ImageType;
	public string ImageSrc
	{
		get { return bi.UriSource.AbsoluteUri; }
		set
		{
			if
			(
				value.EndsWith(".jpg") ||
				value.EndsWith(".png") ||
				value.EndsWith(".ico"))
			{
				ImageType = new string(value.TakeLast(4).ToArray());

				bi = new();
				bi.BeginInit();
				bi.UriSource = new Uri(value);
				bi.EndInit();

				RoundedButtonImage = new();
				RoundedButtonImage.Source = bi;
				this.RoundedButtonBorder.Child = RoundedButtonImage;
			}
			else if (value.EndsWith(".svg"))
			{
				ImageType = ".svg";
				RoundedButtonSvgImage = new();
				RoundedButtonSvgImage.Source = new Uri(value);
				this.RoundedButtonBorder.Child = RoundedButtonSvgImage;
			}
		}
	}

	public BitmapImage BitmapIcon
	{
		get
		{
			return bi;
		}
		set
		{
			RoundedButtonImage = new();
			RoundedButtonImage.Source = bi = value;
			RoundedButtonBorder.Child = RoundedButtonImage;
		}
	}

	BitmapSource bitmapSource;
	public BitmapSource Icon
	{
		get { return bitmapSource; }
		set
		{
			bitmapSource = value;
			RoundedButtonImage = new();
			RoundedButtonImage.Source = bitmapSource;
			RoundedButtonBorder.Child = RoundedButtonImage;
			ImageType = "BitmapSource";
		}
	}

	public int IconWidth
	{
		get
		{
			if (
				ImageType == ".jpg" ||
				ImageType == ".png" ||
				ImageType == ".ico" ||
				ImageType == "BitmapSource"
			)
			{
				return (int)this.RoundedButtonImage.Width;
			}
			else if (ImageType == ".svg")
			{
				return (int)this.RoundedButtonSvgImage.Width;
			}
			return 0;
		}
		set
		{
			if (
				ImageType == ".jpg" ||
				ImageType == ".png" ||
				ImageType == ".ico" ||
				ImageType == "BitmapSource"
			)
			{
				this.RoundedButtonImage.Width = value;
			}
			else if (ImageType == ".svg")
			{
				this.RoundedButtonSvgImage.Width = value;
			}
		}
	}

	public int IconHeight
	{
		get
		{
			if (
				ImageType == ".jpg" ||
				ImageType == ".png" ||
				ImageType == ".ico" ||
				ImageType == "BitmapSource"
			)
			{
				return (int)this.RoundedButtonImage.Height;
			}
			else if (ImageType == ".svg")
			{
				return (int)this.RoundedButtonSvgImage.Height;
			}
			return 0;
		}
		set
		{
			if (
				ImageType == ".jpg" ||
				ImageType == ".png" ||
				ImageType == ".ico" ||
				ImageType == "BitmapSource"
			)
			{
				this.RoundedButtonImage.Height = value;
			}
			else if (ImageType == ".svg")
			{
				this.RoundedButtonSvgImage.Height = value;
			}
		}
	}

	public CornerRadius CornerRadius
	{
		get { return this.RoundedButtonBorder.CornerRadius; }
		set { this.RoundedButtonBorder.CornerRadius = value; }
	}

	public Brush Background
	{
		get { return this.RoundedButtonBorder.Background; }
		set { this.RoundedButtonBorder.Background = value; }
	}

	public Brush Foreground
	{
		get { return this.RoundedButtonTextBlock.Foreground; }
		set { this.RoundedButtonTextBlock.Foreground = value; }
	}

	public Brush BorderBrush
	{
		get { return this.RoundedButtonBorder.BorderBrush; }
		set { this.RoundedButtonBorder.BorderBrush = value; }
	}

	public Thickness BorderThickness
	{
		get { return this.RoundedButtonBorder.BorderThickness; }
		set { this.RoundedButtonBorder.BorderThickness = value; }
	}
	public Brush HoverColor = new SolidColorBrush(Colors.Black);
	public bool _HoverEffect = true;
	public bool HoverEffect
	{
		get { return this._HoverEffect; }
		set
		{
			_HoverEffect = value;
			if (_HoverEffect)
			{
				this.MouseEnter += ChangeToHover;
				this.MouseLeave += RestoreColor;
			}
			else
			{
				this.MouseEnter -= ChangeToHover;
				this.MouseLeave -= RestoreColor;
			}
		}
	}

	public RoundedButton()
	{
		this.Content = RoundedButtonBorder;

		RoundedButtonTextBlock.HorizontalAlignment = HorizontalAlignment.Center;
		RoundedButtonTextBlock.VerticalAlignment = VerticalAlignment.Center;
	}

	public void ChangeToHover(object sender, MouseEventArgs e)
	{
		Background = HoverColor;
	}
    public void RestoreColor(object sender, MouseEventArgs e)
    {
        Background = new SolidColorBrush(Colors.Transparent);
    }
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Ui\StackPanel.cs
SIZE: 2.12 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace sambar;

public class StackPanelWithGaps: StackPanel 
{
    int gap;
    int capacity; 
    public StackPanelWithGaps(int gap, int capacity)
    {
        this.gap = gap;
        this.capacity = capacity;

        if(this.Orientation == Orientation.Horizontal) {
            this.HorizontalAlignment = HorizontalAlignment.Left;
            this.VerticalAlignment = VerticalAlignment.Center; 
        }
        else 
        {
            this.HorizontalAlignment = HorizontalAlignment.Center;
            this.VerticalAlignment = VerticalAlignment.Top;
        }
    }

    int currentElement = 0;
    public void Add(UserControl control) {
        Logger.Log($"currentElement: {currentElement}, capacity: {capacity}");
        if(currentElement < capacity - 1)
        {
            if(this.Orientation == Orientation.Horizontal)
            {
                control.Margin = new(gap, 0, 0, 0);
            }
            else
            {
                control.Margin = new(0, gap, 0, 0);
            }
        } 
        else if(currentElement == capacity - 1)
        {
            if(this.Orientation == Orientation.Horizontal)
            {
                Logger.Log("LAST ELEMENT");
                control.Margin = new(gap, 0, gap, 0);
            }
            else
            {
                control.Margin = new(0, gap, 0, gap);
            }
        }
        else
        {
            var last = this.Children[^1] as UserControl;
            if(this.Orientation == Orientation.Horizontal)
            {
                last.Margin = new(gap, 0, 0, 0);
                control.Margin = new(gap, 0, gap, 0);
            }
            else
            {
                last.Margin = new(0, gap, 0, 0);
                control.Margin = new(0, gap, 0, gap);
            }
            capacity++;
        }
        this.Children.Add(control);
        currentElement++;
    }
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Utils\Core.cs
SIZE: 14.12 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media;
using SharpVectors.Dom.Stylesheets;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Management;
using System.IO;
using System.Windows.Navigation;
using System.Windows;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Net;
using System.ComponentModel;

namespace sambar;

public partial class Utils
{
	public static Brush BrushFromHex(string hexColorString)
	{
		if (hexColorString == "transparent")
		{
			return new SolidColorBrush(Colors.Transparent);
		}
		System.Drawing.Color color = System.Drawing.ColorTranslator.FromHtml(hexColorString);
		return new SolidColorBrush(System.Windows.Media.Color.FromArgb(color.A, color.R, color.G, color.B));
	}

	public static List<string> GetStyleListFromUInt(uint styleUInt)
	{
		WINDOWSTYLE styles = (WINDOWSTYLE)styleUInt;
		List<string> styleList = new();
		foreach (WINDOWSTYLE style in Enum.GetValues(typeof(WINDOWSTYLE)))
		{
			if (styles.HasFlag(style))
			{
				styleList.Add(style.ToString());
			}
		}
		return styleList;
	}

	public static List<string> GetStylesFromHwnd(nint hWnd)
	{
		uint stylesUInt = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_STYLE);
		//Logger.Log($"GetStylesFromHwnd(): {Marshal.GetLastWin32Error()}");
		return GetStyleListFromUInt(stylesUInt);
	}

	public static bool IsContextMenu(nint hWnd)
	{
		var styleList = Utils.GetStylesFromHwnd(hWnd);
		//Logger.Log($"IsContextMenu(): {Marshal.GetLastWin32Error()}");
		if (styleList.Contains("WS_POPUP")) return true;

		string className = Utils.GetClassNameFromHWND(hWnd);
		if (className == "#32768") return true;
		if (className == "#32770") return true;
		if (className == "SysListView32") return true;
		if (className == "SysShadow") return true;
		if (className == "TrayiconMessageWindow") return true;
		if (className == "tray_icon_app") return true;
		return false;
	}

	public static bool IsWindowVisible(nint hWnd)
	{
		var styleList = Utils.GetStylesFromHwnd(hWnd);
		//Logger.Log($"IsWindowVisible(): {Marshal.GetLastWin32Error()}");
		if (styleList.Contains("WS_VISIBLE")) return true;
		return false;
	}

	public static nint GetWindowUnderCursor()
	{
		User32.GetCursorPos(out POINT pt);
		return User32.WindowFromPoint(pt);
	}

	public static void MoveWindowToCursor(nint hWnd, int offsetX = 0, int offsetY = 0)
	{
		User32.GetCursorPos(out POINT cursorPos);
		User32.SetWindowPos(hWnd, nint.Zero, cursorPos.X + offsetX, cursorPos.Y + offsetY, 0, 0, SETWINDOWPOS.SWP_NOSIZE);
	}

	public static void MoveWindow(nint hWnd, int x, int y)
	{
		User32.SetWindowPos(hWnd, nint.Zero, x, y, 0, 0, SETWINDOWPOS.SWP_NOSIZE);
	}

	public static string GetClassNameFromHWND(nint hWnd)
	{
		StringBuilder str = new(256);
		User32.GetClassName(hWnd, str, str.Capacity);
		return str.ToString();
	}

	public static (int, int) GetWindowDimensions(nint hWnd)
	{
		User32.GetWindowRect(hWnd, out RECT rect);
		int Width = rect.Right - rect.Left;
		int Height = rect.Bottom - rect.Top;
		return (Width, Height);
	}

	/// <summary>
	/// Get the top level window matching the given pid
	/// </summary>
	/// <param name="processId"></param>
	/// <returns></returns>
	public static nint GetHWNDFromPID(int processId)
	{
		nint found_hWnd = new();
		EnumWindowProc enumWindowProc = (nint hWnd, nint lParam) =>
		{
			User32.GetWindowThreadProcessId(hWnd, out uint _processId);
			if (_processId == processId)
			{
				found_hWnd = hWnd;
				return false;
			}
			return true;
		};
		User32.EnumWindows(enumWindowProc, (nint)processId);
		return found_hWnd;
	}

	/// <summary>
	/// Enumerate ALL windows (including children)
	/// </summary>
	/// <returns></returns>
	public static List<GUIProcess> EnumWindowProcesses()
	{
		List<GUIProcess> guiProcesses = new();
		EnumWindowProc enumWindowProc = (nint hWnd, nint lParam) =>
		{
			User32.GetWindowThreadProcessId(hWnd, out uint processId);
			Process process = Process.GetProcessById((int)processId);
			GUIProcess guiProcess;
			if ((guiProcess = guiProcesses.Where(_p => _p.name == process.ProcessName).FirstOrDefault()) == null)
			{
				guiProcess = new() { name = process.ProcessName };
				guiProcesses.Add(guiProcess);
			}
			guiProcess.process = process;
			_Window window = new();
			window.hWnd = hWnd;
			window.className = GetClassNameFromHWND(hWnd);
			guiProcess.windows.Add(window);
			EnumWindowProc enumChildWindowProc = (nint c_hWnd, nint lParam) =>
			{
				_Window c_window = new();
				c_window.hWnd = c_hWnd;
				c_window.className = GetClassNameFromHWND(c_hWnd);
				guiProcess.windows.Add(c_window);
				return true;
			};
			User32.EnumChildWindows(hWnd, enumChildWindowProc, nint.Zero);
			return true;
		};
		User32.EnumWindows(enumWindowProc, nint.Zero);
		return guiProcesses;
	}

	public static string? GetExePathFromHWND(nint hWnd)
	{
		User32.GetWindowThreadProcessId(hWnd, out uint processId);

		if (Environment.IsPrivilegedProcess)
		{
			List<GUIProcess> allWindows = EnumWindowProcesses();
			Process? process = allWindows.Where(guiProcess => guiProcess.process.Id == processId).FirstOrDefault()?.process;
			return process?.MainModule?.FileName;
		}

		/// <summary>
		/// Getting module filenames without elevated privileges
		/// NtQuerySystemInformation() := undocumented internal API
		/// https://stackoverflow.com/a/75084784/14588925
		/// </summary>
		SYSTEM_PROCESS_ID_INFORMATION info = new() { ProcessId = (nint)processId, ImageName = new() { Length = 0, MaximumLength = 256, Buffer = Marshal.AllocHGlobal(512) } };
		int result = Ntdll.NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS.SystemProcessIdInformation, ref info, (uint)Marshal.SizeOf<SYSTEM_PROCESS_ID_INFORMATION>(), out uint returnLength);
		string exePath = Marshal.PtrToStringUni(info.ImageName.Buffer);
		Marshal.FreeHGlobal(info.ImageName.Buffer);

		// List all device paths
		List<string> driveDevicePaths = new();
		List<string> driveNames = new();
		Dictionary<string, string> devicePathToDrivePath = new();
		driveNames = DriveInfo.GetDrives().Select(drive => drive.Name.Substring(0, 2)).ToList();
		driveDevicePaths = driveNames.Select(drive =>
		{
			StringBuilder str = new(256);
			Kernel32.QueryDosDevice(drive, str, (uint)str.Capacity);
			string devicePath = str.ToString();
			devicePathToDrivePath[devicePath] = drive;
			return devicePath;
		}).ToList();

		//
		string? exePathDeviceName = driveDevicePaths.Where(path => exePath.Contains(path)).FirstOrDefault();
		if (exePathDeviceName == null) return null;
		string exePathDriveName = devicePathToDrivePath[exePathDeviceName];

		string exeNtPath = Path.Join(exePathDriveName, exePath.Replace(exePathDeviceName, ""));
		return exeNtPath;
	}

	public static int MAKEWPARAM(short L, short H)
	{
		return (int)H << 16 | (int)L;
	}

	public static int MAKELPARAM(short L, short H)
	{
		return (int)H << 16 | (int)L;
	}

	/// <summary>
	/// Determines if a window is visible and running in the Taskbar/Alt-Tab
	/// not the pinned icons in the taskbar, source:
	/// https://stackoverflow.com/questions/210504/enumerate-windows-like-alt-tab-does
	/// </summary>
	/// <param name="hWnd"></param>
	/// <returns></returns>
	public static bool IsWindowInTaskBar(nint hWnd)
	{
		// filter out the obvious -------------------------
		if (!User32.IsWindowVisible(hWnd)) return false;

		uint exStyle = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_EXSTYLE);
		nint dwmOutPtr = Marshal.AllocHGlobal(sizeof(int));
		Dwmapi.DwmGetWindowAttribute(hWnd, (uint)DWMWINDOWATTRIBUTE.DWMWA_CLOAKED, dwmOutPtr, sizeof(int));
		int dwmOutput = Marshal.ReadInt32(dwmOutPtr);
		Marshal.FreeHGlobal(dwmOutPtr);
		string className = GetClassNameFromHWND(hWnd);

		if (exStyle.ContainsFlag((uint)WINDOWSTYLE.WS_EX_TOOLWINDOW)) return false;
		//if (exStyle.ContainsFlag((uint)WINDOWSTYLE.WS_EX_APPWINDOW)) return false;

		if (className == "Windows.UI.Core.CoreWindow") return false;
		if (className == "ApplicationFrameWindow" && dwmOutput != 0) return false;
		// ---------------------------------------------------------------

		// https://devblogs.microsoft.com/oldnewthing/20071008-00/?p=24863 
		const int GA_ROOTOWNER = 3;
		// start at the owner window
		nint hWndWalk = User32.GetAncestor(hWnd, GA_ROOTOWNER);

		nint hWndTry;
		// a window in taskbar / alt-tab is its own last popup window, so loop until hWnd walk becomes a popup window
		while ((hWndTry = User32.GetLastActivePopup(hWndWalk)) != hWndWalk)
		{
			if (IsWindowVisible(hWndTry)) break;
			hWndWalk = hWndTry;
		}
		// once the walk is finished hWndWalk "is" the taskbarwindow in that owner chain, now check if the window you supplied is that window
		return hWnd == hWndWalk;
	}

	/// <summary>
	/// All normal applications with a taskbar icon
	/// </summary>
	/// <returns></returns>
	public static List<nint>? GetAllTaskbarWindows()
	{
		List<nint>? topWindows = new();
		EnumWindowProc enumWnd = (nint hWnd, nint lParam) =>
		{
			topWindows.Add(hWnd);
			return true;
		};
		User32.EnumWindows(enumWnd, nint.Zero);
		var taskbarWindows = topWindows.Where(hWnd => IsWindowInTaskBar(hWnd)).ToList();
		//taskbarWindows.ForEach(hWnd => Logger.Log($"TASKBAR WINDOWS, hWnd: {hWnd}, class: {GetClassNameFromHWND(hWnd)}, exe: {GetExePathFromHWND(hWnd)}"));
		return taskbarWindows;
	}

	/// <summary>
	/// Retreives the local lan ip assigned to your pc in your LAN network
	/// usually in the form 192.168.XX.XX
	/// </summary>
	/// <returns></returns>
	public static IPAddress GetLANIP()
	{
		return NetworkInterface.GetAllNetworkInterfaces()
			.ToList()
			.Select(iface => iface.GetIPProperties().UnicastAddresses
				.Where(addr => addr.Address.AddressFamily == AddressFamily.InterNetwork && addr.PrefixOrigin == PrefixOrigin.Dhcp)
			)
			.Where(list => list.Count() != 0)
			.ToList()[0]
			.ToList()[0]
			.Address;
	}

	/// <summary>
	/// Retrieves the primary network interface in your pc that you 
	/// use for internet, required for monitoring network bandwidths
	/// and speeds. The idea is that the interface that is used for internet
	/// has the local lan ip
	/// </summary>
	/// <returns></returns>
	public static NetworkInterface GetPrimaryNetworkInterface()
	{
		IPAddress addr = GetLANIP();
		var interfaces = NetworkInterface.GetAllNetworkInterfaces().ToList();
		return interfaces.First(iface => iface.GetIPProperties().UnicastAddresses.Select(ucast => ucast.Address).Contains(addr));
	}

	public static int GetInterfaceIndex(NetworkInterface iface)
	{
		return iface.GetIPProperties().GetIPv4Properties().Index;
	}

	public static string GetWindowTitleFromHWND(nint hWnd)
	{
		StringBuilder str = new(256);
		User32.GetWindowText(hWnd, str, str.Capacity);
		return str.ToString();
	}

	public static void CompileFileToDll(string fileName, string dllName, List<(string, string?)>? additionalDllsAndUsings = null)
	{
		string classCode = File.ReadAllText(fileName);
		Thread thread = new(() => WidgetLoader.CompileToDll(classCode, dllName, additionalDllsAndUsings));
		thread.Start();
		thread.Join();
	}

	public static void CompileStringToDll(string classCode, string dllName, List<(string, string?)>? additionalDllsAndUsings = null)
	{
		Thread thread = new(() => WidgetLoader.CompileToDll(classCode, dllName, additionalDllsAndUsings));
		thread.Start();
		thread.Join();
	}

	public static double GetDisplayScaling()
	{
		nint hMon = User32.MonitorFromPoint(new POINT() { X = 0, Y = 0 }, 0x01);
		Shcore.GetDpiForMonitor(hMon, MONITOR_DPI_TYPE.MDT_EFFECTIVE_DPI, out uint dpiX, out uint dpiY);
		return dpiX / 96.0f;
	}

	/// <summary>
	/// Hides window in the alt-tab window by (ADDING the WS_EX_TOOLWINDOW) and 
	/// (REMOVING the WS_EX_APPWINDOW) extended Styles
	/// </summary>
	/// <param name="hWnd"></param>
	/// <returns></returns>
	public static int HideWindowInAltTab(nint hWnd)
	{
		uint exStyles = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_EXSTYLE);
		return User32.SetWindowLong(
			hWnd,
			(int)GETWINDOWLONG.GWL_EXSTYLE,
			(int)((exStyles | (uint)WINDOWSTYLE.WS_EX_TOOLWINDOW) & ~(uint)WINDOWSTYLE.WS_EX_APPWINDOW)
		);
	}

	/// <summary>
	/// Make a window bottom most and stick to desktop by making it unfocusable
	/// This is required especially for creating widget windows that need to 
	/// always be on the background and never recieve focus. This is done by 
	/// adding the WS_EX_NOACTIVATE style.
	///
	/// Still can flicker at activation and gain focus from alt tab selection,
	/// if the window is hidden in alt tab this shouldnt be a concern, however
	/// to avoid these problems sambar.WidgetWindow exists.
	/// </summary>
	public static void StickWindowToBottom(nint hWnd)
	{
		User32.SetWindowPos(hWnd, (nint)(SWPZORDER.HWND_BOTTOM), 0, 0, 0, 0, SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOACTIVATE);
		uint exStyles = User32.GetWindowLong(hWnd, GETWINDOWLONG.GWL_EXSTYLE);
		User32.SetWindowLong(hWnd, (int)GETWINDOWLONG.GWL_EXSTYLE, (int)(exStyles | (uint)WINDOWSTYLE.WS_EX_NOACTIVATE));
	}

	/// <summary>
	/// Get the scaled display resolution of the screen
	/// </summary>
	public static (int, int) GetScreenSize()
	{
		double scale = Utils.GetDisplayScaling();
		int screenWidth = User32.GetSystemMetrics(0);
		int screenHeight = User32.GetSystemMetrics(1);
		screenWidth = (int)(screenWidth / scale);
		screenHeight = (int)(screenHeight / scale);
		return (screenWidth, screenHeight);
	}

	/// <summary>
	/// Scale an image so that it fills the target rect (width*height) completely
	/// </summary>
	public static void ScaleImage(System.Windows.Controls.Image img, int width, int height)
	{
		if (width > height)
			img.Width = width;
		else
			img.Height = height;
	}
}

public class _Window
{
	public string name;
	public string className;
	public nint hWnd;
}

public class GUIProcess
{
	public string name;
	public Process process;
	public List<_Window> windows = new();
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Utils\Extensions.cs
SIZE: 1.45 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows.Media.Imaging;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;
using System.Diagnostics;

namespace sambar;

public static class Extensions
{
	public static bool ContainsFlag(this uint flag, uint flagToCheck)
	{
		if ((flag & flagToCheck) != 0)
		{
			return true;
		}
		return false;
	}

	public static BitmapImage FromBitmap(this BitmapImage self, Bitmap bitmap)
	{
		using (MemoryStream ms = new())
		{
			bitmap.Save(ms, ImageFormat.Png);
			ms.Position = 0;

			self.BeginInit();
			self.StreamSource = ms;
			self.CacheOption = BitmapCacheOption.OnLoad;
			self.EndInit();
			self.Freeze();

			Logger.Log($"ICON_B: {bitmap.Width}x{bitmap.Height}");
			Logger.Log($"ICON_BP: {self.Width}x{self.Height}");
			return self;
		}
	}

	/// <summary>
	/// Adds a context menu to any WPF control
	/// </summary>
	public static void SetContextMenu(this System.Windows.Controls.Control self, List<(string, Action<object, object>)> nameActionPairs)
	{
		System.Windows.Controls.ContextMenu ctxMenu = new();
		foreach (var pair in nameActionPairs)
		{
			System.Windows.Controls.MenuItem menuItem = new()
			{
				Header = pair.Item1,
			};
			menuItem.Click += (s, e) =>
			{
				pair.Item2(s, e);
			};
			ctxMenu.Items.Add(menuItem);
		}
		self.ContextMenu = ctxMenu;
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Utils\Logger.cs
SIZE: 3.25 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.IO;

namespace sambar;

public class Logger
{
	public static bool DEBUG = true;
	public static bool CONSOLE = true;
	public static bool FILE = true;

	public static FileStream logFile = File.Open(Paths.logFile, FileMode.OpenOrCreate);
	public static StreamWriter logFileWriter = new(logFile);

	public static void Log(string? text, bool debug = true, bool console = true, bool file = true)
	{
		if (DEBUG && debug) Debug.WriteLine(text);
		if (CONSOLE && console) Console.WriteLine(text);
		if (FILE && file) logFileWriter.WriteLine(text);
	}

	public static void Log(List<string> array)
	{
		foreach (var arr in array) Log(arr);
	}
}

public class LoggerWindow
{
	Window? wnd;
	FrameworkElement? content;
	TextBlock? debugConsole;
	bool initialized = false;
	public LoggerWindow(Type? contentType = null, dynamic[]? contentConstructorArgs = null, Action<Window>? wndInit = null)
	{
		// window runs on a separate thread so that UI heavy updates dont
		// slow down the main UI thread.
		Thread thread = new(() =>
		{
			wnd = new();
			wnd.Width = 800;
			wnd.Height = 400;

			//wnd.WindowStyle = WindowStyle.None;
			//wnd.AllowsTransparency = true;
			//wnd.Background = new SolidColorBrush(Colors.Transparent);
			wndInit?.Invoke(wnd);

			Grid grid = new();
			RowDefinition _row1 = new() { Height = new GridLength(1, GridUnitType.Star) };
			RowDefinition _row2 = new() { Height = new GridLength(0.25, GridUnitType.Star) };

			grid.RowDefinitions.Add(_row1);
			grid.RowDefinitions.Add(_row2);

			if (contentType != null)
			{
				// all this so that this windows content UIElement can be created in this thread
				content = (FrameworkElement?)Activator.CreateInstance(contentType, contentConstructorArgs);
				content!.Height = 3 * wnd.Height / 4;
				content!.Width = wnd.Width;
				wnd.SizeChanged += (s, e) =>
				{
					content.Height = 3 * e.NewSize.Height / 4;
					content.Width = e.NewSize.Width;
				};
				Grid.SetRow(content, 0);
				grid.Children.Add(content);
			}

			debugConsole = new();
			ScrollViewer scrollViewer = new();
			scrollViewer.Margin = new(5);
			scrollViewer.Content = debugConsole;

			Grid.SetRow(scrollViewer, 1);
			grid.Children.Add(scrollViewer);

			wnd.Content = grid;
			wnd.Show();

			initialized = true;
			System.Windows.Threading.Dispatcher.Run();
		});
		thread.SetApartmentState(ApartmentState.STA);
		thread.IsBackground = true;
		thread.Start();
	}

	// to get a reference to the window's primary content to write to it
	public FrameworkElement? GetContent()
	{
		while (!initialized) Thread.Sleep(1);
		return content;
	}

	public void Log(string message)
	{
		if (debugConsole == null) return;
		wnd?.Dispatcher.Invoke(() =>
		{
			debugConsole.Text += "\n" + message;
		});
	}

	// to set the properties of windows primary content because it is owned by a separate thread
	public void SetContentProperty(Action<FrameworkElement?> contentPropertySetterLambda)
	{
		while (!initialized) Thread.Sleep(1);
		wnd?.Dispatcher.Invoke(() =>
		{
			contentPropertySetterLambda(content);
		});
	}
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Win32\Delegates.cs
SIZE: 0.32 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

namespace sambar;

public delegate bool EnumWindowProc(nint hWnd, nint lParam);
public delegate nint WNDPROC(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam);
public delegate void TIMERPROC(nint hWnd, uint param2, nint param3, ulong param4);





================================================================================
FILE: :\DEV\sambar\Src\Classes\Win32\Enums.cs
SIZE: 21.86 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Drawing;

namespace sambar;

public enum WINDOWSTYLE : uint
{
	WS_OVERLAPPED = 0x00000000,
	WS_POPUP = 0x80000000,
	WS_CHILD = 0x40000000,
	WS_MINIMIZE = 0x20000000,
	WS_VISIBLE = 0x10000000,
	WS_DISABLED = 0x08000000,
	WS_CLIPSIBLINGS = 0x04000000,
	WS_CLIPCHILDREN = 0x02000000,
	WS_MAXIMIZE = 0x01000000,
	WS_BORDER = 0x00800000,
	WS_DLGFRAME = 0x00400000,
	WS_VSCROLL = 0x00200000,
	WS_HSCROLL = 0x00100000,
	WS_SYSMENU = 0x00080000,
	WS_THICKFRAME = 0x00040000,
	WS_GROUP = 0x00020000,
	WS_TABSTOP = 0x00010000,

	WS_MINIMIZEBOX = 0x00020000,
	WS_MAXIMIZEBOX = 0x00010000,

	WS_CAPTION = WS_BORDER | WS_DLGFRAME,
	WS_TILED = WS_OVERLAPPED,
	WS_ICONIC = WS_MINIMIZE,
	WS_SIZEBOX = WS_THICKFRAME,
	WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW,

	WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
	WS_POPUPWINDOW = WS_POPUP | WS_BORDER | WS_SYSMENU,
	WS_CHILDWINDOW = WS_CHILD,

	//Extended Window Styles

	WS_EX_DLGMODALFRAME = 0x00000001,
	WS_EX_NOPARENTNOTIFY = 0x00000004,
	WS_EX_TOPMOST = 0x00000008,
	WS_EX_ACCEPTFILES = 0x00000010,
	WS_EX_TRANSPARENT = 0x00000020,

	//#if(WINVER >= 0x0400)

	WS_EX_MDICHILD = 0x00000040,
	WS_EX_TOOLWINDOW = 0x00000080,
	WS_EX_WINDOWEDGE = 0x00000100,
	WS_EX_CLIENTEDGE = 0x00000200,
	WS_EX_CONTEXTHELP = 0x00000400,

	WS_EX_RIGHT = 0x00001000,
	WS_EX_LEFT = 0x00000000,
	WS_EX_RTLREADING = 0x00002000,
	WS_EX_LTRREADING = 0x00000000,
	WS_EX_LEFTSCROLLBAR = 0x00004000,
	WS_EX_RIGHTSCROLLBAR = 0x00000000,

	WS_EX_CONTROLPARENT = 0x00010000,
	WS_EX_STATICEDGE = 0x00020000,
	WS_EX_APPWINDOW = 0x00040000,

	WS_EX_OVERLAPPEDWINDOW = (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE),
	WS_EX_PALETTEWINDOW = (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST),

	//#endif /* WINVER >= 0x0400 */

	//#if(WIN32WINNT >= 0x0500)

	WS_EX_LAYERED = 0x00080000,

	//#endif /* WIN32WINNT >= 0x0500 */

	//#if(WINVER >= 0x0500)

	WS_EX_NOINHERITLAYOUT = 0x00100000, // Disable inheritence of mirroring by children
	WS_EX_LAYOUTRTL = 0x00400000, // Right to left mirroring

	//#endif /* WINVER >= 0x0500 */

	//#if(WIN32WINNT >= 0x0500)

	WS_EX_COMPOSITED = 0x02000000,
	WS_EX_NOACTIVATE = 0x08000000

	//#endif /* WIN32WINNT >= 0x0500 */
}

public enum DWMWINDOWATTRIBUTE : uint
{
	DWMWA_NCRENDERING_ENABLED,
	DWMWA_NCRENDERING_POLICY,
	DWMWA_TRANSITIONS_FORCEDISABLED,
	DWMWA_ALLOW_NCPAINT,
	DWMWA_CAPTION_BUTTON_BOUNDS,
	DWMWA_NONCLIENT_RTL_LAYOUT,
	DWMWA_FORCE_ICONIC_REPRESENTATION,
	DWMWA_FLIP3D_POLICY,
	DWMWA_EXTENDED_FRAME_BOUNDS,
	DWMWA_HAS_ICONIC_BITMAP,
	DWMWA_DISALLOW_PEEK,
	DWMWA_EXCLUDED_FROM_PEEK,
	DWMWA_CLOAK,
	/// <summary>
	/// cloaked := invisible
	/// </summary>
	DWMWA_CLOAKED = 14,
	DWMWA_FREEZE_REPRESENTATION,
	DWMWA_PASSIVE_UPDATE_MODE,
	DWMWA_USE_HOSTBACKDROPBRUSH,
	DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
	DWMWA_WINDOW_CORNER_PREFERENCE = 33,
	DWMWA_BORDER_COLOR,
	DWMWA_CAPTION_COLOR,
	DWMWA_TEXT_COLOR,
	DWMWA_VISIBLE_FRAME_BORDER_THICKNESS,
	DWMWA_SYSTEMBACKDROP_TYPE,
	DWMWA_LAST
}

public enum DWM_CLOAK_STATE
{
	DWM_CLOAKED_APP = 0x00000001,
	DWM_CLOAKED_SHELL = 0x00000002,
	DWM_CLOAKED_INHERITED = 0x00000004
}

public enum DWM_WINDOW_CORNER_PREFERENCE
{
	DWMWCP_DEFAULT = 0,
	DWMWCP_DONOTROUND = 1,
	DWMWCP_ROUND = 2,
	DWMWCP_ROUNDSMALL = 3
}

public enum APPBARMESSAGE
{
	New = 0x00,
	Remove = 0x01,
	QueryPos = 0x02,
	SetPos = 0x03,
	GetState = 0x04,
	GetTaskBarPos = 0x05,
	Activate = 0x06,
	GetAutoHideBar = 0x07,
	SetAutoHideBar = 0x08,
	WindowPosChanged = 0x09,
	SetState = 0x0a
}

public enum APPBARSTATE
{
	AutoHide = 0x01,
	AlwaysOnTop = 0x02
}

public enum SHOWWINDOW
{
	SW_HIDE = 0,
	SW_SHOWNORMAL = 1,
	SW_MAXIMIZE = 3,
	SW_SHOW = 5
}

public enum SETWINDOWPOS : uint
{
	SWP_NOSIZE = 0x0001,
	SWP_NOMOVE = 0x0002,
	SWP_NOACTIVATE = 0x0010

}

public enum SWPZORDER : int
{
	HWND_BOTTOM = 1,
	HWND_NOTOPMOST = -2,
	HWND_TOP = 0,
	HWND_TOPMOST = -1
}

public enum GETWINDOWLONG : int
{
	GWL_STYLE = -16,
	GWL_EXSTYLE = -20
}

public enum WINDOWMESSAGE : uint
{

	// Window Message Constants
	WM_ACTIVATE = 0x0006,
	WM_ACTIVATEAPP = 0x001C,
	WM_AFXFIRST = 0x0360,
	WM_AFXLAST = 0x037F,
	WM_APP = 0x8000,
	WM_ASKCBFORMATNAME = 0x030C,
	WM_CANCELJOURNAL = 0x004B,
	WM_CANCELMODE = 0x001F,
	WM_CAPTURECHANGED = 0x0215,
	WM_CHANGECBCHAIN = 0x030D,
	WM_CHANGEUISTATE = 0x0127,
	WM_CHAR = 0x0102,
	WM_CHARTOITEM = 0x002F,
	WM_CHILDACTIVATE = 0x0022,
	WM_CLEAR = 0x0303,
	WM_CLOSE = 0x0010,
	WM_COMMAND = 0x0111,
	WM_COMPACTING = 0x0041,
	WM_COMPAREITEM = 0x0039,
	WM_CONTEXTMENU = 0x007B,
	WM_COPY = 0x0301,
	WM_COPYDATA = 0x004A,
	WM_CREATE = 0x0001,
	WM_CTLCOLORBTN = 0x0135,
	WM_CTLCOLORDLG = 0x0136,
	WM_CTLCOLOREDIT = 0x0133,
	WM_CTLCOLORLISTBOX = 0x0134,
	WM_CTLCOLORMSGBOX = 0x0132,
	WM_CTLCOLORSCROLLBAR = 0x0137,
	WM_CTLCOLORSTATIC = 0x0138,
	WM_CUT = 0x0300,
	WM_DEADCHAR = 0x0103,
	WM_DELETEITEM = 0x002D,
	WM_DESTROY = 0x0002,
	WM_DESTROYCLIPBOARD = 0x0307,
	WM_DEVICECHANGE = 0x0219,
	WM_DEVMODECHANGE = 0x001B,
	WM_DISPLAYCHANGE = 0x007E,
	WM_DRAWCLIPBOARD = 0x0308,
	WM_DRAWITEM = 0x002B,
	WM_DROPFILES = 0x0233,
	WM_ENABLE = 0x000A,
	WM_ENDSESSION = 0x0016,
	WM_ENTERIDLE = 0x0121,
	WM_ENTERMENULOOP = 0x0211,
	WM_ENTERSIZEMOVE = 0x0231,
	WM_ERASEBKGND = 0x0014,
	WM_EXITMENULOOP = 0x0212,
	WM_EXITSIZEMOVE = 0x0232,
	WM_FONTCHANGE = 0x001D,
	WM_GETDLGCODE = 0x0087,
	WM_GETFONT = 0x0031,
	WM_GETHOTKEY = 0x0033,
	WM_GETICON = 0x007F,
	WM_GETMINMAXINFO = 0x0024,
	WM_GETOBJECT = 0x003D,
	WM_GETTEXT = 0x000D,
	WM_GETTEXTLENGTH = 0x000E,
	WM_HANDHELDFIRST = 0x0358,
	WM_HANDHELDLAST = 0x035F,
	WM_HELP = 0x0053,
	WM_HOTKEY = 0x0312,
	WM_HSCROLL = 0x0114,
	WM_HSCROLLCLIPBOARD = 0x030E,
	WM_ICONERASEBKGND = 0x0027,
	WM_IME_CHAR = 0x0286,
	WM_IME_COMPOSITION = 0x010F,
	WM_IME_COMPOSITIONFULL = 0x0284,
	WM_IME_CONTROL = 0x0283,
	WM_IME_ENDCOMPOSITION = 0x010E,
	WM_IME_KEYDOWN = 0x0290,
	WM_IME_KEYLAST = 0x010F,
	WM_IME_KEYUP = 0x0291,
	WM_IME_NOTIFY = 0x0282,
	WM_IME_REQUEST = 0x0288,
	WM_IME_SELECT = 0x0285,
	WM_IME_SETCONTEXT = 0x0281,
	WM_IME_STARTCOMPOSITION = 0x010D,
	WM_INITDIALOG = 0x0110,
	WM_INITMENU = 0x0116,
	WM_INITMENUPOPUP = 0x0117,
	WM_INPUTLANGCHANGE = 0x0051,
	WM_INPUTLANGCHANGEREQUEST = 0x0050,
	WM_KEYDOWN = 0x0100,
	WM_KEYFIRST = 0x0100,
	WM_KEYLAST = 0x0108,
	WM_KEYUP = 0x0101,
	WM_KILLFOCUS = 0x0008,
	WM_LBUTTONDBLCLK = 0x0203,
	WM_LBUTTONDOWN = 0x0201,
	WM_LBUTTONUP = 0x0202,
	WM_MBUTTONDBLCLK = 0x0209,
	WM_MBUTTONDOWN = 0x0207,
	WM_MBUTTONUP = 0x0208,
	WM_MDIACTIVATE = 0x0222,
	WM_MDICASCADE = 0x0227,
	WM_MDICREATE = 0x0220,
	WM_MDIDESTROY = 0x0221,
	WM_MDIGETACTIVE = 0x0229,
	WM_MDIICONARRANGE = 0x0228,
	WM_MDIMAXIMIZE = 0x0225,
	WM_MDINEXT = 0x0224,
	WM_MDIREFRESHMENU = 0x0234,
	WM_MDIRESTORE = 0x0223,
	WM_MDISETMENU = 0x0230,
	WM_MDITILE = 0x0226,
	WM_MEASUREITEM = 0x002C,
	WM_MENUCHAR = 0x0120,
	WM_MENUCOMMAND = 0x0126,
	WM_MENUDRAG = 0x0123,
	WM_MENUGETOBJECT = 0x0124,
	WM_MENURBUTTONUP = 0x0122,
	WM_MENUSELECT = 0x011F,
	WM_MOUSEACTIVATE = 0x0021,
	WM_MOUSEFIRST = 0x0200,
	WM_MOUSEHOVER = 0x02A1,
	WM_MOUSELAST = 0x020D,
	WM_MOUSELEAVE = 0x02A3,
	WM_MOUSEMOVE = 0x0200,
	WM_MOUSEWHEEL = 0x020A,
	WM_MOUSEHWHEEL = 0x020E,
	WM_MOVE = 0x0003,
	WM_MOVING = 0x0216,
	WM_NCACTIVATE = 0x0086,
	WM_NCCALCSIZE = 0x0083,
	WM_NCCREATE = 0x0081,
	WM_NCDESTROY = 0x0082,
	WM_NCHITTEST = 0x0084,
	WM_NCLBUTTONDBLCLK = 0x00A3,
	WM_NCLBUTTONDOWN = 0x00A1,
	WM_NCLBUTTONUP = 0x00A2,
	WM_NCMBUTTONDBLCLK = 0x00A9,
	WM_NCMBUTTONDOWN = 0x00A7,
	WM_NCMBUTTONUP = 0x00A8,
	WM_NCMOUSEHOVER = 0x02A0,
	WM_NCMOUSELEAVE = 0x02A2,
	WM_NCMOUSEMOVE = 0x00A0,
	WM_NCPAINT = 0x0085,
	WM_NCRBUTTONDBLCLK = 0x00A6,
	WM_NCRBUTTONDOWN = 0x00A4,
	WM_NCRBUTTONUP = 0x00A5,
	WM_NCXBUTTONDBLCLK = 0x00AD,
	WM_NCXBUTTONDOWN = 0x00AB,
	WM_NCXBUTTONUP = 0x00AC,
	WM_NCUAHDRAWCAPTION = 0x00AE,
	WM_NCUAHDRAWFRAME = 0x00AF,
	WM_NEXTDLGCTL = 0x0028,
	WM_NEXTMENU = 0x0213,
	WM_NOTIFY = 0x004E,
	WM_NOTIFYFORMAT = 0x0055,
	WM_NULL = 0x0000,
	WM_PAINT = 0x000F,
	WM_PAINTCLIPBOARD = 0x0309,
	WM_PAINTICON = 0x0026,
	WM_PALETTECHANGED = 0x0311,
	WM_PALETTEISCHANGING = 0x0310,
	WM_PARENTNOTIFY = 0x0210,
	WM_PASTE = 0x0302,
	WM_PENWINFIRST = 0x0380,
	WM_PENWINLAST = 0x038F,
	WM_POWER = 0x0048,
	WM_POWERBROADCAST = 0x0218,
	WM_PRINT = 0x0317,
	WM_PRINTCLIENT = 0x0318,
	WM_QUERYDRAGICON = 0x0037,
	WM_QUERYENDSESSION = 0x0011,
	WM_QUERYNEWPALETTE = 0x030F,
	WM_QUERYOPEN = 0x0013,
	WM_QUEUESYNC = 0x0023,
	WM_QUIT = 0x0012,
	WM_RBUTTONDBLCLK = 0x0206,
	WM_RBUTTONDOWN = 0x0204,
	WM_RBUTTONUP = 0x0205,
	WM_RENDERALLFORMATS = 0x0306,
	WM_RENDERFORMAT = 0x0305,
	WM_SETCURSOR = 0x0020,
	WM_SETFOCUS = 0x0007,
	WM_SETFONT = 0x0030,
	WM_SETHOTKEY = 0x0032,
	WM_SETICON = 0x0080,
	WM_SETREDRAW = 0x000B,
	WM_SETTEXT = 0x000C,
	WM_SETTINGCHANGE = 0x001A,
	WM_SHOWWINDOW = 0x0018,
	WM_SIZE = 0x0005,
	WM_SIZECLIPBOARD = 0x030B,
	WM_SIZING = 0x0214,
	WM_SPOOLERSTATUS = 0x002A,
	WM_STYLECHANGED = 0x007D,
	WM_STYLECHANGING = 0x007C,
	WM_SYNCPAINT = 0x0088,
	WM_SYSCHAR = 0x0106,
	WM_SYSCOLORCHANGE = 0x0015,
	WM_SYSCOMMAND = 0x0112,
	WM_SYSDEADCHAR = 0x0107,
	WM_SYSKEYDOWN = 0x0104,
	WM_SYSKEYUP = 0x0105,
	WM_TCARD = 0x0052,
	WM_TIMECHANGE = 0x001E,
	WM_TIMER = 0x0113,
	WM_UNDO = 0x0304,
	WM_UNINITMENUPOPUP = 0x0125,
	WM_USER = 0x0400,
	WM_USERCHANGED = 0x0054,
	WM_VKEYTOITEM = 0x002E,
	WM_VSCROLL = 0x0115,
	WM_VSCROLLCLIPBOARD = 0x030A,
	WM_WINDOWPOSCHANGED = 0x0047,
	WM_WINDOWPOSCHANGING = 0x0046,
	WM_WININICHANGE = 0x001A,
	WM_XBUTTONDBLCLK = 0x020D,
	WM_XBUTTONDOWN = 0x020B,
	WM_XBUTTONUP = 0x020C,
}

/// <summary>
/// WM_COPYDATA message sent to Taskbar [Shell_TrayWnd] carries data
/// in its lpData field which is one of the three 
/// different types identified by its dwData field
/// </summary>
public enum SHELLTRAYMESSAGE : int
{
	// Resolve to SHELLTRAYDATA struct to use data for ICONUPDATE
	ICONUPDATE = 1,
	APPBAR = 2,
	TRAYICONPOSITION = 3
}

public enum ICONUPDATEACTION : uint
{
	NIM_ADD = 0x00000000,
	NIM_MODIFY = 0x00000001,
	NIM_DELETE = 0x00000002,
	NIM_SETFOCUS = 0x00000003,
	NIM_SETVERSION = 0x00000004
}

public enum NOTIFYICONDATAVALIDITY : uint
{
	NIF_MESSAGE = 0x00000001,
	NIF_ICON = 0x00000002,
	NIF_TIP = 0x00000004,
	NIF_STATE = 0x00000008,
	NIF_INFO = 0x00000010,
	NIF_GUID = 0x00000020,
	NIF_REALTIME = 0x00000040,
	NIF_SHOWTIP = 0x00000080
}

public enum SYSCOMMAND : uint
{
	SC_SIZE = 0xF000,           // Sizes the window
	SC_MOVE = 0xF010,           // Moves the window
	SC_MINIMIZE = 0xF020,       // Minimizes the window
	SC_MAXIMIZE = 0xF030,       // Maximizes the window
	SC_NEXTWINDOW = 0xF040,     // Moves to the next window
	SC_PREVWINDOW = 0xF050,     // Moves to the previous window
	SC_CLOSE = 0xF060,          // Closes the window
	SC_VSCROLL = 0xF070,        // Scrolls vertically
	SC_HSCROLL = 0xF080,        // Scrolls horizontally
	SC_MOUSEMENU = 0xF090,      // Retrieves the window menu as a result of a mouse click
	SC_KEYMENU = 0xF100,        // Retrieves the window menu as a result of a keystroke
	SC_RESTORE = 0xF120,        // Restores the window to its normal position and size
	SC_TASKLIST = 0xF130,       // Activates the Start menu
	SC_SCREENSAVE = 0xF140,     // Executes the screen saver application specified in the [boot] section of the System.ini file
	SC_HOTKEY = 0xF150,         // Activates the window associated with the application-specified hot key
	SC_DEFAULT = 0xF160,        // Selects the default item; the user double-clicked the window menu
	SC_MONITORPOWER = 0xF170,   // Sets the state of the display (supports power-saving features)
	SC_CONTEXTHELP = 0xF180     // Changes the cursor to a question mark with a pointer
}

public enum ANIMATEWINDOW : uint
{
	AW_HOR_POSITIVE = 0x00000001,
	AW_HOR_NEGATIVE = 0x00000002,
	AW_VER_POSITIVE = 0x00000004,
	AW_VER_NEGATIVE = 0x00000008,
	AW_CENTER = 0x00000010,
	AW_HIDE = 0x00010000,
	AW_ACTIVATE = 0x00020000,
	AW_SLIDE = 0x00040000,
	AW_BLEND = 0x00080000
}

/// <summary>
/// System Information Class enumeration for NtQuerySystemInformation
/// Based on Windows NT kernel system information classes
/// </summary>
public enum SYSTEM_INFORMATION_CLASS : uint
{
	SystemBasicInformation = 0x00,
	SystemProcessorInformation = 0x01,
	SystemPerformanceInformation = 0x02,
	SystemTimeOfDayInformation = 0x03,
	SystemPathInformation = 0x04,
	SystemProcessInformation = 0x05,
	SystemCallCountInformation = 0x06,
	SystemDeviceInformation = 0x07,
	SystemProcessorPerformanceInformation = 0x08,
	SystemFlagsInformation = 0x09,
	SystemCallTimeInformation = 0x0A,
	SystemModuleInformation = 0x0B,
	SystemLocksInformation = 0x0C,
	SystemStackTraceInformation = 0x0D,
	SystemPagedPoolInformation = 0x0E,
	SystemNonPagedPoolInformation = 0x0F,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1A,
	SystemUnloadGdiDriverInformation = 0x1B,
	SystemTimeAdjustmentInformation = 0x1C,
	SystemSummaryMemoryInformation = 0x1D,
	SystemMirrorMemoryInformation = 0x1E,
	SystemPerformanceTraceInformation = 0x1F,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2A,
	SystemLegacyDriverInformation = 0x2B,
	SystemCurrentTimeZoneInformation = 0x2C,
	SystemLookasideInformation = 0x2D,
	SystemTimeSlipNotification = 0x2E,
	SystemSessionCreate = 0x2F,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3A,
	SystemComPlusPackage = 0x3B,
	SystemNumaAvailableMemory = 0x3C,
	SystemProcessorPowerInformation = 0x3D,
	SystemEmulationBasicInformation = 0x3E,
	SystemEmulationProcessorInformation = 0x3F,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4A,
	SystemRegisterFirmwareTableInformationHandler = 0x4B,
	SystemFirmwareTableInformation = 0x4C,
	SystemModuleInformationEx = 0x4D,
	SystemVerifierTriageInformation = 0x4E,
	SystemSuperfetchInformation = 0x4F,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5A,
	SystemHypervisorInformation = 0x5B,
	SystemVerifierInformationEx = 0x5C,
	SystemTimeZoneInformation = 0x5D,
	SystemImageFileExecutionOptionsInformation = 0x5E,
	SystemCoverageInformation = 0x5F,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6A,
	SystemLogicalProcessorAndGroupInformation = 0x6B,
	SystemProcessorCycleTimeInformation = 0x6C,
	SystemStoreInformation = 0x6D,
	SystemRegistryAppendString = 0x6E,
	SystemAitSamplingValue = 0x6F,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7A,
	SystemBasicPerformanceInformation = 0x7B,
	SystemQueryPerformanceCounterInformation = 0x7C,
	SystemSessionBigPoolInformation = 0x7D,
	SystemBootGraphicsInformation = 0x7E,
	SystemScrubPhysicalMemoryInformation = 0x7F,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemPolicyInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8A,
	SystemMemoryChannelInformation = 0x8B,
	SystemBootLogoInformation = 0x8C,
	SystemProcessorPerformanceInformationEx = 0x8D,
	SystemCriticalProcessErrorLogInformation = 0x8E,
	SystemSecureBootPolicyInformation = 0x8F,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9A,
	SystemRegistryReconciliationInformation = 0x9B,
	SystemEdidInformation = 0x9C,
	SystemManufacturingInformation = 0x9D,
	SystemEnergyEstimationConfigInformation = 0x9E,
	SystemHypervisorDetailInformation = 0x9F,
	SystemProcessorCycleStatsInformation = 0xA0,
	SystemVmGenerationCountInformation = 0xA1,
	SystemTrustedPlatformModuleInformation = 0xA2,
	SystemKernelDebuggerFlags = 0xA3,
	SystemCodeIntegrityPolicyInformation = 0xA4,
	SystemIsolatedUserModeInformation = 0xA5,
	SystemHardwareSecurityTestInterfaceResultsInformation = 0xA6,
	SystemSingleModuleInformation = 0xA7,
	SystemAllowedCpuSetsInformation = 0xA8,
	SystemDmaProtectionInformation = 0xA9,
	SystemInterruptCpuSetsInformation = 0xAA,
	SystemSecureBootPolicyFullInformation = 0xAB,
	SystemCodeIntegrityPolicyFullInformation = 0xAC,
	SystemAffinitizedInterruptProcessorInformation = 0xAD,
	SystemRootSiloInformation = 0xAE,
	SystemCpuSetInformation = 0xAF,
	SystemCpuSetTagInformation = 0xB0,
	SystemWin32WerStartCallout = 0xB1,
	SystemSecureKernelProfileInformation = 0xB2,
	SystemCodeIntegrityPlatformManifestInformation = 0xB3,
	SystemInterruptSteeringInformation = 0xB4,
	SystemSuppportedProcessorArchitectures = 0xB5,
	SystemMemoryUsageInformation = 0xB6,
	SystemCodeIntegrityCertificateInformation = 0xB7,
	SystemPhysicalMemoryInformation = 0xB8,
	SystemControlFlowTransition = 0xB9,
	SystemKernelDebuggingAllowed = 0xBA,
	SystemActivityModerationExeState = 0xBB,
	SystemActivityModerationUserSettings = 0xBC,
	SystemCodeIntegrityPoliciesFullInformation = 0xBD,
	SystemCodeIntegrityUnlockInformation = 0xBE,
	SystemIntegrityQuotaInformation = 0xBF,
	SystemFlushInformation = 0xC0,
	SystemProcessorIdleMaskInformation = 0xC1,
	SystemSecureDumpEncryptionInformation = 0xC2,
	SystemWriteConstraintInformation = 0xC3,
	SystemKernelVaShadowInformation = 0xC4,
	SystemHypervisorSharedPageInformation = 0xC5,
	SystemFirmwareBootPerformanceInformation = 0xC6,
	SystemCodeIntegrityVerificationInformation = 0xC7,
	SystemFirmwarePartitionInformation = 0xC8,
	SystemSpeculationControlInformation = 0xC9,
	SystemDmaGuardPolicyInformation = 0xCA,
	SystemEnclaveLaunchControlInformation = 0xCB,
	SystemWorkloadAllowedCpuSetsInformation = 0xCC,
	SystemCodeIntegrityUnlockModeInformation = 0xCD,
	SystemLeapSecondInformation = 0xCE,
	SystemFlags2Information = 0xCF,
	SystemSecurityModelInformation = 0xD0,
	SystemCodeIntegritySyntheticCacheInformation = 0xD1,
	SystemFeatureConfigurationInformation = 0xD2,
	SystemFeatureConfigurationSectionInformation = 0xD3,
	SystemFeatureUsageSubscriptionInformation = 0xD4,
	SystemSecureSpeculationControlInformation = 0xD5,
	MaxSystemInfoClass = 0xD6
}

public enum ADRESS_FAMILY : uint
{
	AF_INET = 2,
	AF_INET6 = 23
}

/// <summary>
/// Used by GetScaleFactorForMonitor()
/// </summary>
public enum DEVICE_SCALE_FACTOR : uint
{
	DEVICE_SCALE_FACTOR_INVALID = 0,
	SCALE_100_PERCENT = 100,
	SCALE_120_PERCENT = 120,
	SCALE_125_PERCENT = 125,
	SCALE_140_PERCENT = 140,
	SCALE_150_PERCENT = 150,
	SCALE_160_PERCENT = 160,
	SCALE_175_PERCENT = 175,
	SCALE_180_PERCENT = 180,
	SCALE_200_PERCENT = 200,
	SCALE_225_PERCENT = 225,
	SCALE_250_PERCENT = 250,
	SCALE_300_PERCENT = 300,
	SCALE_350_PERCENT = 350,
	SCALE_400_PERCENT = 400,
	SCALE_450_PERCENT = 450,
	SCALE_500_PERCENT = 500
}

public enum MONITOR_DPI_TYPE
{
	MDT_EFFECTIVE_DPI = 0,
	MDT_ANGULAR_DPI = 1,
	MDT_RAW_DPI = 2,
	MDT_DEFAULT
}




================================================================================
FILE: :\DEV\sambar\Src\Classes\Win32\Functions.cs
SIZE: 9.84 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Text;
using SharpVectors.Dom;

namespace sambar;

public class User32
{
	// user32
	[DllImport("user32.dll", SetLastError = true)]
	public static extern int SetWindowLong(nint hWnd, int nIndex, int dwNewLong);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern uint GetWindowLong(nint hWnd, GETWINDOWLONG nIndex);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int GetWindowText(nint hWnd, StringBuilder lpString, int nMaxCount);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int SetWindowPos(nint hWnd, nint hWndInsertAfter, int x, int y, int cx, int cy, SETWINDOWPOS uFlags);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int GetSystemMetrics(int nIndex);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint FindWindow(string className, string windowName);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int ShowWindow(nint hWnd, SHOWWINDOW nCmdShow);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint FindWindowEx(nint hWndParent, nint hWndChildAfter, string className, string windowName);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int ShowWindowAsync(nint hWnd, SHOWWINDOW nCmdShow);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool GetWindowPlacement(nint hWnd, ref WINDOWPLACEMENT lpwndpl);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool GetCursorPos(out POINT cursorPos);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool GetWindowRect(nint hWnd, out RECT windowRect);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool GetClientRect(nint hWnd, out RECT clientRect);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint GetForegroundWindow();

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int SetForegroundWindow(nint hWnd);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int AllowSetForegroundWindow(uint dwProcessId);

	[DllImport("user32.dll")]
	public static extern nint WindowFromPoint(POINT Point);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int GetClassName(nint hWnd, StringBuilder lpClassName, int nMaxCount);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool EnumWindows(EnumWindowProc enumWindowProc, nint lParam);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool EnumChildWindows(nint hWndParent, EnumWindowProc enumWindowProc, nint lParam);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool GetWindowThreadProcessId(nint hWnd, out uint processId);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint CreateWindowEx(
		WINDOWSTYLE dwExStyle,
		string lpClassName,
		string lpWindowName,
		WINDOWSTYLE dwStyle,
		int X,
		int Y,
		int nWidth,
		int nHeight,
		nint hWndParent,
		nint hMenu,
		nint hInstance,
		nint lpParam
	);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern ushort RegisterClassEx(ref WNDCLASSEX wc);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool UnregisterClass(string className, nint hInstance);

	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern nint GetModuleHandle(string moduleName);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint DefWindowProc(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int DestroyWindow(nint hWnd);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int GetMessage(out MSG msg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool TranslateMessage(ref MSG msg);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern bool DispatchMessage(ref MSG msg);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern void PostQuitMessage(int nExitCode);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern uint RegisterWindowMessage(string message);

	/// <summary>
	/// Use when msg is not in WINDOWMESSAGE enum, like in situations where a new boradcast
	/// message has to be sent
	/// </summary>
	/// <param name="hWnd"></param>
	/// <param name="msg"></param>
	/// <param name="wParam"></param>
	/// <param name="lParam"></param>
	/// <returns></returns>

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int SendNotifyMessage(
		nint hWnd,
		uint msg,
		nint wParam,
		nint lParam
	);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern int SendMessage(
		nint hWnd,
		uint msg,
		nint wParam,
		nint lParam
	);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern void SetTimer(nint hWnd, nint nIdEvent, uint uElapse, TIMERPROC timerProc);

	[DllImport("user32.dll", SetLastError = true)]
	public extern static nint GetAncestor(
	  nint hwnd,
	  uint gaFlags
	);

	[DllImport("user32.dll", SetLastError = true)]
	public extern static nint GetLastActivePopup(
		nint hWnd
	);

	[DllImport("user32.dll", SetLastError = true)]
	public extern static bool IsWindowVisible(nint hWnd);

	[DllImport("user32.dll", SetLastError = true)]
	public extern static int AnimateWindow(nint hWnd, uint dwTime, ANIMATEWINDOW dwFlags);

	// return hMonitor or the monitor handle

	[DllImport("user32.dll", SetLastError = true)]
	public extern static nint MonitorFromPoint(POINT pt, uint dwFlags);

	[DllImport("user32.dll", SetLastError = true)]
	public extern static nint MonitorFromWindow(nint hWnd, uint dwFlags);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern nint SetParent(nint hWndChild, nint hWndNewParent);
}

public class Shell32
{
	[DllImport("shell32.dll", SetLastError = true)]
	public static extern uint SHAppBarMessage(uint dwMessage, ref APPBARDATA pData);

	[DllImport("shell32.dll", SetLastError = true)]
	public static extern long Shell_NotifyIconGetRect(ref _NOTIFYICONIDENTIFIER identifier, out RECT iconLocation);

	[DllImport("shell32.dll", SetLastError = true)]
	public static extern uint ExtractIconEx(string exePath, int nIconIndex, out nint iconLarge, out nint iconSmall, uint nIcons);
}

public class Kernel32
{
	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern bool AttachConsole(int processId);

	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern nint GetModuleHandle(string moduleName);

	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern nint OpenProcess(uint processAccess, bool bInheritHandle, int processId);

	[DllImport("kernel32.dll")]
	public static extern uint GetLogicalDriveStringsW(
	  uint nBufferLength,
	  StringBuilder lpBuffer
	);

	[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern uint QueryDosDevice(
	  string lpDeviceName,
	  StringBuilder lpTargetPath,
	  uint ucchMax
	);
}

public class Dwmapi
{
	[DllImport("dwmapi.dll", SetLastError = true)]
	public static extern int DwmSetWindowAttribute(nint hWnd, DWMWINDOWATTRIBUTE attr, ref int attrValue, int attrSize);

	[DllImport("dwmapi.dll", SetLastError = true)]
	public static extern int DwmGetWindowAttribute(
		nint hWnd,
		uint dwAttribute,
		nint pvAttribute,
		uint cbAttribute
	);
}

public class Psapi
{
	[DllImport("psapi.dll", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern uint GetModuleFileNameEx(nint hProcess, nint hModule, out StringBuilder moduleFileName, uint nSize);
}

/// <summary>
/// Query kernel objects
/// </summary>
public class Ntdll
{
	[DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern int NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS infoType, ref SYSTEM_PROCESS_ID_INFORMATION info, uint infoLength, out uint returnLength);

	[DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern int NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS infoType, ref SYSTEM_BASIC_INFORMATION info, uint infoLength, out uint returnLength);

	[DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
	public static extern int NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS infoType, nint info, uint infoLength, out uint returnLength);

}

public class Shcore
{
	// retrieves monitor scaling info
	// MONITOR_DEFAULTTONULL
	// 0x00000000
	// Returns NULL.
	// MONITOR_DEFAULTTOPRIMARY
	// 0x00000001
	// Returns a handle to the primary display monitor.
	// MONITOR_DEFAULTTONEAREST
	// 0x00000002
	// Returns a handle to the display monitor that is nearest to the point.
	[DllImport("shcore.dll", SetLastError = true)]
	public static extern int GetScaleFactorForMonitor(nint hMon, out DEVICE_SCALE_FACTOR scaleFactor);

	[DllImport("shcore.dll", SetLastError = true)]
	public static extern int GetDpiForMonitor(nint hMon, MONITOR_DPI_TYPE dpiType, out uint dpiX, out uint dpiY);

}

public class Iphlpapi
{
	/// <summary>
	/// https://learn.microsoft.com/en-us/windows/win32/api/netioapi/nf-netioapi-getipnetworkconnectionbandwidthestimates
	/// </summary>
	/// <param name="interfaceIndex"></param>
	/// <param name="adressFamily"></param>
	/// <param name="info"></param>
	/// <returns></returns>
	[DllImport("iphlpapi.dll", SetLastError = true)]
	public static extern int GetIpNetworkConnectionBandwidthEstimates(int interfaceIndex, ADRESS_FAMILY adressFamily, out _MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES info);
}

public class Winmm
{

}



================================================================================
FILE: :\DEV\sambar\Src\Classes\Win32\Structs.cs
SIZE: 7.38 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Runtime.InteropServices;
using System.Drawing;

namespace sambar;

/// <summary>
/// DWORD := uint
/// HWND  := nint
/// PVOID := nint
/// </summary>
/// ------------------------

/// <summary>
/// For controlling the visibility and autohide behaviours of the taksbar
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct APPBARDATA
{
    public uint cbSize;
    public nint hWnd;
    public uint uCallbackMessage;
    public uint uEdge;
    public Rectangle rc;
    public uint lParam;
}

[StructLayout(LayoutKind.Sequential)]
public struct POINT 
{
	public int X;
	public int Y;
}

[StructLayout(LayoutKind.Sequential)]
public struct RECT
{
	public int Left;
	public int Top;
	public int Right;
	public int Bottom;
}

[StructLayout(LayoutKind.Sequential)]
public struct WINDOWPLACEMENT
{
	public uint length;
	public uint flags;
	public uint showCmd;
	public POINT ptMinPosition;
	public POINT ptMaxPosition;
	public RECT rcNormalPosition;
	public RECT rcDevice;
}

/// <summary>
/// struct that applications use to query its tray icon information using
/// Shell_NotifyIcon() and Shell_NotifyIconGetRect(), these functions would then send
/// another internal struct [_NOTIFYICONIDENTIFIERINTERNAL] containing additional items 
/// to Shell_TrayWnd
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct _NOTIFYICONIDENTIFIER {
	public uint cbSize;
	public nint hWnd;
	public uint UID;
	public Guid guidItem;
}

[StructLayout(LayoutKind.Sequential)]
public struct _NOTIFYICONIDENTIFIERINTERNAL
{
	//--------------------
	public int magicNumber;
	public int msg;
	//---------------------
	public int callbackSize;
	//---------------------
	public int padding;
	//---------------------
	public nint hWnd;
	public uint UID;
	public Guid guidItem;
}

[StructLayout(LayoutKind.Sequential)]
public struct WNDCLASSEX
{
	public uint cbSize;
	public uint style;
	public WNDPROC lpfnWndProc;
	public int cbClsExtra;
	public int cbWndExtra;
	public nint hInstance;
	public nint hIcon;
	public nint hCurosr;
	public nint hbrBackground;
	public string lpszMenuName;
	public string lpszClassName;
	public nint hIconSm;
}

[StructLayout(LayoutKind.Sequential)]
public struct COPYDATASTRUCT
{
	public ulong dwData;
	public ulong cbData;
	public nint lpData;
}

[StructLayout(LayoutKind.Explicit)]
public struct TIMEOUTVERSIONUNION
{
	[FieldOffset(0)]
	public uint uTimeout;
	[FieldOffset(0)]
	public uint uVersion;
}

/// <summary>
/// Very delicate struct, you might also notice that hWnd is an uint instead of the usual nint
/// (IntPtr)
/// </summary>

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct NOTIFYICONDATA
{
	public uint cbSize;
	/// <summary>
	/// Window handle of the message processing window for the tray icon. This is NOT
	/// the handle to the actual icon's window, the actual icon might not even have a window
	/// to begin with (which is the case with XAML elements)
	/// </summary>
	public uint hWnd;
	public uint uID;
	public uint uFlags;
	/// <summary>
	/// SendMessage(hWnd, uCallbackMessage, ..., ...) 
	/// Wait what ? ......^...
	/// isnt it supposed to be a window message defined in WINDOWMESSAGE such as WM_CONTEXTMENU 
	/// or WM_RIGHTBUTTONDOWN ? well the actual window the gets the WM_RIGHTBUTTONDOWN when 
	/// the icon is rightclicked is the window hoisting the icon TopLevelXamlOverflowWindow
	/// or even Shell_TrayWnd. It then requests the message processing window of the icon (window with handle hWnd)
	/// for a context menu.
	/// </summary>
	public uint uCallbackMessage;
	public uint hIcon;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string szTip;
	public uint dwState;
	public uint dwStateMask;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	public string szInfo;
	public TIMEOUTVERSIONUNION uTimeoutOrVersion;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
	public string szInfoTitle;
	public uint dwInfoFlags;
	public Guid guidItem;
	public uint hBalloonIcon;
}

/// <summary>
/// Message Type recieved or send to Taskbar [Shell_TrayWnd]
/// during the WM_COPYDATA event
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct SHELLTRAYICONUPDATEDATA
{
	public int dwHz;
	public uint dwMessage;
	public NOTIFYICONDATA nid;
}

/// <summary>
/// Win32 basic window message type used by SendMessage(), GetMessage(), TranslateMessage()
/// DispatchMessage() etc
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct MSG
{
	public nint hwnd;
	public WINDOWMESSAGE message;
	public nint wParam;
	public nint lParam;
	public uint time;
	public POINT pt;
	public uint lPrivate;
}

[StructLayout(LayoutKind.Sequential)]
public struct UNICODE_STRING
{
	public ushort Length;
	public ushort MaximumLength;
	public nint Buffer;
}

/// <summary>
/// Used by NtQuerySystemInformation in ntdll to query process module paths without 
/// elevated priveleges. Part of the undocumented windows api
/// SYSTEM_INFORMATION_CLASS.SystemProcessIdInformation
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_PROCESS_ID_INFORMATION
{
	public nint ProcessId;
	public UNICODE_STRING ImageName;
}

/// <summary>
/// NtQuerySystemInformation() can use it for basic querrying
/// used with SYSTEM_INFORMATION_CLASS.SystemBasicInformation
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_BASIC_INFORMATION
{
   public uint Reserved;
   public uint TimerResolution;
   public uint PageSize;
   public uint NumberOfPhysicalPages;
   public uint LowestPhysicalPageNumber;
   public uint HighestPhysicalPageNumber;
   public uint AllocationGranularity;
   public UIntPtr MinimumUserModeAddress;
   public UIntPtr MaximumUserModeAddress;
   public UIntPtr ActiveProcessorsAffinityMask;
   public byte NumberOfProcessors;
}

/// <summary>
/// Used by SYSTEM_INFORMATION_CLASS.SystemProcessorPerformanceInformation
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
{
	public long IdleTime;
	public long KernelTime;
	public long UserTime;
	public long DpcTime;
	public long InterruptTime;
	public uint Reserved2;
}

[StructLayout(LayoutKind.Sequential)]
public struct _NL_BANDWIDTH_INFORMATION {
  public ulong Bandwidth;
  public ulong Instability;
  public byte BandwidthPeaked;
}

/// <summary>
/// https://learn.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_ip_network_connection_bandwidth_estimates
/// </summary>

[StructLayout(LayoutKind.Sequential)]
public struct _MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES {
  public _NL_BANDWIDTH_INFORMATION InboundBandwidthInformation;
  public _NL_BANDWIDTH_INFORMATION OutboundBandwidthInformation;
}

/// <summary>
/// used by SYSTEM_INFORMATION_CLASS.SystemMemoryUsageInformation
/// https://ntdoc.m417z.com/system_memory_usage_information
/// </summary>
[StructLayout(LayoutKind.Sequential)]
public struct _SYSTEM_MEMORY_USAGE_INFORMATION { 
    public ulong TotalPhysicalBytes;
    public ulong AvailableBytes;
    public long ResidentAvailableBytes;
    public ulong CommittedBytes;
    public long SharedCommittedBytes;
    public long CommitLimitBytes;
    public long PeakCommitmentBytes; 
}





================================================================================
FILE: :\DEV\sambar\Src\Main.cs
SIZE: 1.45 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

/*
	MIT License
    Copyright (c) 2025 Ajaykrishnan R	
*/

using System.Windows;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using System.IO;
using System.Diagnostics;
using System.Reflection;

namespace sambar;

public class _Main
{
	public static Application app;

	[STAThread]
	static void Main(string[] args)
	{
		// for logger
		Kernel32.AttachConsole(-1);

		// check for already running instances 
		if (Process.GetProcessesByName("sambar").Length > 1)
		{
			Logger.Log("An instance is already running, exiting ...");
			return;
		}

		Paths.CreateIfAbsent();

		// evaluate the .init.cs to get the widget pack name
		string? widgetPackName = WidgetLoader.GetObjectFromScript<string>(Paths.initCsFile);
		if (widgetPackName == null) return;

		Logger.Log($"Compiling config");
		string configFile = Path.Join(Paths.widgetPacksFolder, widgetPackName, ".config.cs");
		if (!File.Exists(configFile))
		{
			Logger.Log("widget pack does not contain .config.cs file");
			return;
		}
		Utils.CompileFileToDll(configFile, ".config");
		Assembly configAssembly = Assembly.LoadFile(Paths.configDll);
		Type configType = configAssembly.GetTypes().Where(type => type.IsSubclassOf(typeof(Config))).First();
		Config config = (Config)Activator.CreateInstance(configType);

		// start the wpf bar window
		app = new();
		Sambar sambar = new(widgetPackName, config);
		app.Run(sambar);
	}
}



================================================================================
FILE: :\DEV\sambar\Src\Properties\launchSettings.json
SIZE: 0.15 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

{
  "profiles": {
    "sambar": {
      "commandName": "Project",
      "workingDirectory": "C:\\Users\\Jayakuttan\\dev\\sambar\\Src"
    }
  }
}


================================================================================
FILE: :\DEV\sambar\Src\sambar.csproj
SIZE: 1.46 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net9.0-windows10.0.26100.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="WidgetPacks\**" />
    <Compile Remove="scripts\**" />
    <Compile Remove="Tests\**" />
    <Compile Remove="Classes\Hooks\**" />
  </ItemGroup>

  <ItemGroup>
    <None Include="WidgetPacks\**" />
    <None Include="Tests\**" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="FftSharp" Version="2.2.0" />
    <PackageReference Include="FlaUI.UIA3" Version="5.0.0" />
    <PackageReference Include="Interop.UIAutomationClient.Signed" Version="10.19041.0">
      <Aliases>IUIAutimationInteropNuget</Aliases>
    </PackageReference>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Scripting" Version="4.14.0" />
    <PackageReference Include="NAudio" Version="2.2.1" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="ScottPlot.WPF" Version="5.0.56" />
    <PackageReference Include="SharpVectors.Wpf" Version="1.8.4.2" />
    <PackageReference Include="SkiaSharp.Views.WPF" Version="3.119.0" />
    <PackageReference Include="System.Drawing.Common" Version="9.0.6" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="_.dll\" />
  </ItemGroup>

</Project>



================================================================================
FILE: :\DEV\sambar\Src\Tests\Interceptor.cs
SIZE: 15.03 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System.Runtime.InteropServices;
using System.Text;

[StructLayout(LayoutKind.Sequential)]
public struct WNDCLASSEX
{
	public uint cbSize;
	public uint style;
	public Program.WNDPROC lpfnWndProc;
	public int cbClsExtra;
	public int cbWndExtra;
	public nint hInstance;
	public nint hIcon;
	public nint hCursor;
	public nint hbrBackground;
	public string lpszMenuName;
	public string lpszClassName;
	public nint hIconSm;
}

public enum WINDOWSTYLE : ulong
{
	WS_OVERLAPPED = 0x00000000,
	WS_POPUP = 0x80000000,
	WS_CHILD = 0x40000000,
	WS_MINIMIZE = 0x20000000,
	WS_VISIBLE = 0x10000000,
	WS_DISABLED = 0x08000000,
	WS_CLIPSIBLINGS = 0x04000000,
	WS_CLIPCHILDREN = 0x02000000,
	WS_MAXIMIZE = 0x01000000,
	WS_BORDER = 0x00800000,
	WS_DLGFRAME = 0x00400000,
	WS_VSCROLL = 0x00200000,
	WS_HSCROLL = 0x00100000,
	WS_SYSMENU = 0x00080000,
	WS_THICKFRAME = 0x00040000,
	WS_GROUP = 0x00020000,
	WS_TABSTOP = 0x00010000,

	WS_MINIMIZEBOX = 0x00020000,
	WS_MAXIMIZEBOX = 0x00010000,

	WS_CAPTION = WS_BORDER | WS_DLGFRAME,
	WS_TILED = WS_OVERLAPPED,
	WS_ICONIC = WS_MINIMIZE,
	WS_SIZEBOX = WS_THICKFRAME,
	WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW,

	WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
	WS_POPUPWINDOW = WS_POPUP | WS_BORDER | WS_SYSMENU,
	WS_CHILDWINDOW = WS_CHILD,

	//Extended Window Styles

	WS_EX_DLGMODALFRAME = 0x00000001,
	WS_EX_NOPARENTNOTIFY = 0x00000004,
	WS_EX_TOPMOST = 0x00000008,
	WS_EX_ACCEPTFILES = 0x00000010,
	WS_EX_TRANSPARENT = 0x00000020,

	//#if(WINVER >= 0x0400)

	WS_EX_MDICHILD = 0x00000040,
	WS_EX_TOOLWINDOW = 0x00000080,
	WS_EX_WINDOWEDGE = 0x00000100,
	WS_EX_CLIENTEDGE = 0x00000200,
	WS_EX_CONTEXTHELP = 0x00000400,

	WS_EX_RIGHT = 0x00001000,
	WS_EX_LEFT = 0x00000000,
	WS_EX_RTLREADING = 0x00002000,
	WS_EX_LTRREADING = 0x00000000,
	WS_EX_LEFTSCROLLBAR = 0x00004000,
	WS_EX_RIGHTSCROLLBAR = 0x00000000,

	WS_EX_CONTROLPARENT = 0x00010000,
	WS_EX_STATICEDGE = 0x00020000,
	WS_EX_APPWINDOW = 0x00040000,

	WS_EX_OVERLAPPEDWINDOW = (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE),
	WS_EX_PALETTEWINDOW = (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST),

	//#endif /* WINVER >= 0x0400 */

	//#if(WIN32WINNT >= 0x0500)

	WS_EX_LAYERED = 0x00080000,

	//#endif /* WIN32WINNT >= 0x0500 */

	//#if(WINVER >= 0x0500)

	WS_EX_NOINHERITLAYOUT = 0x00100000, // Disable inheritence of mirroring by children
	WS_EX_LAYOUTRTL = 0x00400000, // Right to left mirroring

	//#endif /* WINVER >= 0x0500 */

	//#if(WIN32WINNT >= 0x0500)

	WS_EX_COMPOSITED = 0x02000000,
	WS_EX_NOACTIVATE = 0x08000000

	//#endif /* WIN32WINNT >= 0x0500 */
}


[StructLayout(LayoutKind.Sequential)]
struct POINT
{
	public long X;
	public long Y;
}

struct MSG
{
	public nint hwnd;
	public WINDOWMESSAGE message;
	public nint wParam;
	public nint lParam;
	public ulong time;
	public POINT pt;
	public ulong lPrivate;
}

public class Program
{
	[DllImport("user32.dll", SetLastError = true)]
	static extern ushort RegisterClassEx(ref WNDCLASSEX wc);

	[DllImport("user32.dll", SetLastError = true)]
	static extern bool UnregisterClass(string className, nint hInstance);

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nint GetModuleHandle(string moduleName);

	public delegate nint WNDPROC(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam);

	[DllImport("user32.dll", SetLastError = true)]
	static extern nint DefWindowProc(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam);

	[DllImport("user32.dll", SetLastError = true)]
	public static extern nint CreateWindowEx(
		WINDOWSTYLE dwExStyle,
		string lpClassName,
		string lpWindowName,
		WINDOWSTYLE dwStyle,
		int X,
		int Y,
		int nWidth,
		int nHeight,
		nint hWndParent,
		nint hMenu,
		nint hInstance,
		nint lpParam
	);

	[DllImport("user32.dll", SetLastError = true)]
	static extern int ShowWindow(nint hWnd, int nCmdShow);

	[DllImport("user32.dll", SetLastError = true)]
	static extern int SetWindowPos(
		nint hWnd,
		nint hWndAfter,
		int X,
		int Y,
		int cx,
		int cy,
		SETWINDOWPOS uFlags
	);

	[DllImport("user32.dll", SetLastError = true)]
	static extern int DestroyWindow(nint hWnd);

	[DllImport("user32.dll", SetLastError = true)]
	static extern int GetMessage(out MSG msg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

	[DllImport("user32.dll", SetLastError = true)]
	static extern bool TranslateMessage(ref MSG msg);

	[DllImport("user32.dll", SetLastError = true)]
	static extern bool DispatchMessage(ref MSG msg);

	[DllImport("user32.dll", SetLastError = true)]
	static extern void PostQuitMessage(int nExitCode);

	[DllImport("user32.dll", SetLastError = true)]
	static extern uint RegisterWindowMessage(string message);

	[DllImport("user32.dll", SetLastError = true)]
	static extern int SendNotifyMessage(
		nint hWnd,
		uint msg,
		nint wParam,
		nint lParam
	);


	public delegate void TIMERPROC(nint hWnd, uint param2, nint param3, ulong param4);

	[DllImport("user32.dll", SetLastError = true)]
	static extern void SetTimer(nint hWnd, nint nIdEvent, uint uElapse, TIMERPROC timerProc);

	[DllImport("user32.dll", SetLastError = true)]
	static extern void GetClassName(nint hWnd, StringBuilder className, int maxCount);

	static string _GetClassName(nint hWnd)
	{
		StringBuilder builder = new(256);
		GetClassName(hWnd, builder, builder.Capacity);
		return builder.ToString();
	}

	static nint WndProc(nint hWnd, WINDOWMESSAGE uMsg, nint wParam, nint lParam)
	{
		Console.WriteLine($"Message: {uMsg}");
		switch (uMsg)
		{
			case WINDOWMESSAGE.WM_CLOSE:
				DestroyWindow(hWnd);
				return 0;
			case WINDOWMESSAGE.WM_DESTROY:
				PostQuitMessage(0);
				return 0;
			case WINDOWMESSAGE.WM_TIMER:
				SetWindowPos(hWnd, (nint)(-1), 0, 0, 0, 0, SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOACTIVATE);
				return 0;
			case WINDOWMESSAGE.WM_COPYDATA:
				COPYDATASTRUCT copydata = Marshal.PtrToStructure<COPYDATASTRUCT>(lParam);

				if (copydata.cbData == 0) return 0;

				SHELLTRAYDATA shellTrayData = Marshal.PtrToStructure<SHELLTRAYDATA>(copydata.lpData);

				NOTIFYICONDATA notifyIconData = shellTrayData.nid;

				switch ((TASKBARMESSAGE)copydata.dwData)
				{
					case TASKBARMESSAGE.NIM_ADD:
						Console.WriteLine($"Icon add");
						return 0;
					case TASKBARMESSAGE.NIM_MODIFY:
						Console.WriteLine($"Icon modify, {copydata.cbData}");
						Console.WriteLine($"uid: {notifyIconData.uID}, hWnd: {notifyIconData.hWnd}, tip: {notifyIconData.szTip}, tipCount: {notifyIconData.szTip.Count()}, cbSize: {notifyIconData.cbSize}");
						return 0;
				}
				return 0;
			default:
				return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}
	}

	static void Main()
	{
		WNDCLASSEX wc = new();
		wc.cbSize = (uint)Marshal.SizeOf<WNDCLASSEX>();
		wc.lpfnWndProc = WndProc;
		wc.hInstance = GetModuleHandle(null);
		wc.lpszClassName = "Shell_TrayWnd";

		ushort result = RegisterClassEx(ref wc);
		if (result == 0)
		{
			Console.WriteLine($"RegisterClassEx() failed: {Marshal.GetLastWin32Error()}");
		}
		else
		{
			Console.WriteLine($"RegisterClassEx() success !");
		}

		nint hWnd = CreateWindowEx(
			WINDOWSTYLE.WS_EX_TOPMOST | WINDOWSTYLE.WS_EX_TOOLWINDOW,
			wc.lpszClassName,
			null,
			WINDOWSTYLE.WS_POPUP | WINDOWSTYLE.WS_CLIPCHILDREN | WINDOWSTYLE.WS_CLIPSIBLINGS,
			0,
			0,
			0,
			0,
			nint.Zero,
			nint.Zero,
			nint.Zero,
			nint.Zero
		);

		//ShowWindow(hWnd, 5);
		if (SetWindowPos(hWnd, (nint)(-1), 0, 0, 0, 0, SETWINDOWPOS.SWP_NOMOVE | SETWINDOWPOS.SWP_NOSIZE | SETWINDOWPOS.SWP_NOACTIVATE) == 0)
		{
			Console.WriteLine($"SetWindowPos() failed: {Marshal.GetLastWin32Error()}");
		}

		//SetTimer(hWnd, 1, 100, null);
		uint taskbarCreatedMsg = RegisterWindowMessage("TaskbarCreated");
		SendNotifyMessage((nint)0xffff, taskbarCreatedMsg, 0, 0);

		while (GetMessage(out MSG msg, hWnd, 0, 0) > 0)
		{
			TranslateMessage(ref msg);
			DispatchMessage(ref msg);
		}

		//UnregisterClass(wc.lpszClassName, nint.Zero);
	}
}

[StructLayout(LayoutKind.Sequential)]
public struct COPYDATASTRUCT
{
	public ulong dwData;
	public ulong cbData;
	public nint lpData;
}

[StructLayout(LayoutKind.Explicit)]
public struct TimeoutVersionUnion
{
	[FieldOffset(0)]
	public uint uTimeout;
	[FieldOffset(0)]
	public uint uVersion;
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct NOTIFYICONDATA
{
	public uint cbSize;
	public uint hWnd;
	public uint uID;
	public uint uFlags;
	public uint uCallbackMessage;
	public uint hIcon;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	public string szTip;
	public uint dwState;
	public uint dwStateMask;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	public string szInfo;
	public TimeoutVersionUnion uTimeoutOrVersion;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
	public string szInfoTitle;
	public uint dwInfoFlags;
	public Guid guidItem;
	public uint hBalloonIcon;
}

[StructLayout(LayoutKind.Sequential)]
public struct SHELLTRAYDATA
{
	public int dwHz;
	public uint dwMessage;
	public NOTIFYICONDATA nid;
}

public enum SETWINDOWPOS : uint
{
	SWP_NOSIZE = 0x0001,
    SWP_NOMOVE = 0x0002,
    SWP_NOACTIVATE = 0x0010
}

public enum WINDOWMESSAGE : uint
{

	// Window Message Constants
	WM_ACTIVATE = 0x0006,
	WM_ACTIVATEAPP = 0x001C,
	WM_AFXFIRST = 0x0360,
	WM_AFXLAST = 0x037F,
	WM_APP = 0x8000,
	WM_ASKCBFORMATNAME = 0x030C,
	WM_CANCELJOURNAL = 0x004B,
	WM_CANCELMODE = 0x001F,
	WM_CAPTURECHANGED = 0x0215,
	WM_CHANGECBCHAIN = 0x030D,
	WM_CHANGEUISTATE = 0x0127,
	WM_CHAR = 0x0102,
	WM_CHARTOITEM = 0x002F,
	WM_CHILDACTIVATE = 0x0022,
	WM_CLEAR = 0x0303,
	WM_CLOSE = 0x0010,
	WM_COMMAND = 0x0111,
	WM_COMPACTING = 0x0041,
	WM_COMPAREITEM = 0x0039,
	WM_CONTEXTMENU = 0x007B,
	WM_COPY = 0x0301,
	WM_COPYDATA = 0x004A,
	WM_CREATE = 0x0001,
	WM_CTLCOLORBTN = 0x0135,
	WM_CTLCOLORDLG = 0x0136,
	WM_CTLCOLOREDIT = 0x0133,
	WM_CTLCOLORLISTBOX = 0x0134,
	WM_CTLCOLORMSGBOX = 0x0132,
	WM_CTLCOLORSCROLLBAR = 0x0137,
	WM_CTLCOLORSTATIC = 0x0138,
	WM_CUT = 0x0300,
	WM_DEADCHAR = 0x0103,
	WM_DELETEITEM = 0x002D,
	WM_DESTROY = 0x0002,
	WM_DESTROYCLIPBOARD = 0x0307,
	WM_DEVICECHANGE = 0x0219,
	WM_DEVMODECHANGE = 0x001B,
	WM_DISPLAYCHANGE = 0x007E,
	WM_DRAWCLIPBOARD = 0x0308,
	WM_DRAWITEM = 0x002B,
	WM_DROPFILES = 0x0233,
	WM_ENABLE = 0x000A,
	WM_ENDSESSION = 0x0016,
	WM_ENTERIDLE = 0x0121,
	WM_ENTERMENULOOP = 0x0211,
	WM_ENTERSIZEMOVE = 0x0231,
	WM_ERASEBKGND = 0x0014,
	WM_EXITMENULOOP = 0x0212,
	WM_EXITSIZEMOVE = 0x0232,
	WM_FONTCHANGE = 0x001D,
	WM_GETDLGCODE = 0x0087,
	WM_GETFONT = 0x0031,
	WM_GETHOTKEY = 0x0033,
	WM_GETICON = 0x007F,
	WM_GETMINMAXINFO = 0x0024,
	WM_GETOBJECT = 0x003D,
	WM_GETTEXT = 0x000D,
	WM_GETTEXTLENGTH = 0x000E,
	WM_HANDHELDFIRST = 0x0358,
	WM_HANDHELDLAST = 0x035F,
	WM_HELP = 0x0053,
	WM_HOTKEY = 0x0312,
	WM_HSCROLL = 0x0114,
	WM_HSCROLLCLIPBOARD = 0x030E,
	WM_ICONERASEBKGND = 0x0027,
	WM_IME_CHAR = 0x0286,
	WM_IME_COMPOSITION = 0x010F,
	WM_IME_COMPOSITIONFULL = 0x0284,
	WM_IME_CONTROL = 0x0283,
	WM_IME_ENDCOMPOSITION = 0x010E,
	WM_IME_KEYDOWN = 0x0290,
	WM_IME_KEYLAST = 0x010F,
	WM_IME_KEYUP = 0x0291,
	WM_IME_NOTIFY = 0x0282,
	WM_IME_REQUEST = 0x0288,
	WM_IME_SELECT = 0x0285,
	WM_IME_SETCONTEXT = 0x0281,
	WM_IME_STARTCOMPOSITION = 0x010D,
	WM_INITDIALOG = 0x0110,
	WM_INITMENU = 0x0116,
	WM_INITMENUPOPUP = 0x0117,
	WM_INPUTLANGCHANGE = 0x0051,
	WM_INPUTLANGCHANGEREQUEST = 0x0050,
	WM_KEYDOWN = 0x0100,
	WM_KEYFIRST = 0x0100,
	WM_KEYLAST = 0x0108,
	WM_KEYUP = 0x0101,
	WM_KILLFOCUS = 0x0008,
	WM_LBUTTONDBLCLK = 0x0203,
	WM_LBUTTONDOWN = 0x0201,
	WM_LBUTTONUP = 0x0202,
	WM_MBUTTONDBLCLK = 0x0209,
	WM_MBUTTONDOWN = 0x0207,
	WM_MBUTTONUP = 0x0208,
	WM_MDIACTIVATE = 0x0222,
	WM_MDICASCADE = 0x0227,
	WM_MDICREATE = 0x0220,
	WM_MDIDESTROY = 0x0221,
	WM_MDIGETACTIVE = 0x0229,
	WM_MDIICONARRANGE = 0x0228,
	WM_MDIMAXIMIZE = 0x0225,
	WM_MDINEXT = 0x0224,
	WM_MDIREFRESHMENU = 0x0234,
	WM_MDIRESTORE = 0x0223,
	WM_MDISETMENU = 0x0230,
	WM_MDITILE = 0x0226,
	WM_MEASUREITEM = 0x002C,
	WM_MENUCHAR = 0x0120,
	WM_MENUCOMMAND = 0x0126,
	WM_MENUDRAG = 0x0123,
	WM_MENUGETOBJECT = 0x0124,
	WM_MENURBUTTONUP = 0x0122,
	WM_MENUSELECT = 0x011F,
	WM_MOUSEACTIVATE = 0x0021,
	WM_MOUSEFIRST = 0x0200,
	WM_MOUSEHOVER = 0x02A1,
	WM_MOUSELAST = 0x020D,
	WM_MOUSELEAVE = 0x02A3,
	WM_MOUSEMOVE = 0x0200,
	WM_MOUSEWHEEL = 0x020A,
	WM_MOUSEHWHEEL = 0x020E,
	WM_MOVE = 0x0003,
	WM_MOVING = 0x0216,
	WM_NCACTIVATE = 0x0086,
	WM_NCCALCSIZE = 0x0083,
	WM_NCCREATE = 0x0081,
	WM_NCDESTROY = 0x0082,
	WM_NCHITTEST = 0x0084,
	WM_NCLBUTTONDBLCLK = 0x00A3,
	WM_NCLBUTTONDOWN = 0x00A1,
	WM_NCLBUTTONUP = 0x00A2,
	WM_NCMBUTTONDBLCLK = 0x00A9,
	WM_NCMBUTTONDOWN = 0x00A7,
	WM_NCMBUTTONUP = 0x00A8,
	WM_NCMOUSEHOVER = 0x02A0,
	WM_NCMOUSELEAVE = 0x02A2,
	WM_NCMOUSEMOVE = 0x00A0,
	WM_NCPAINT = 0x0085,
	WM_NCRBUTTONDBLCLK = 0x00A6,
	WM_NCRBUTTONDOWN = 0x00A4,
	WM_NCRBUTTONUP = 0x00A5,
	WM_NCXBUTTONDBLCLK = 0x00AD,
	WM_NCXBUTTONDOWN = 0x00AB,
	WM_NCXBUTTONUP = 0x00AC,
	WM_NCUAHDRAWCAPTION = 0x00AE,
	WM_NCUAHDRAWFRAME = 0x00AF,
	WM_NEXTDLGCTL = 0x0028,
	WM_NEXTMENU = 0x0213,
	WM_NOTIFY = 0x004E,
	WM_NOTIFYFORMAT = 0x0055,
	WM_NULL = 0x0000,
	WM_PAINT = 0x000F,
	WM_PAINTCLIPBOARD = 0x0309,
	WM_PAINTICON = 0x0026,
	WM_PALETTECHANGED = 0x0311,
	WM_PALETTEISCHANGING = 0x0310,
	WM_PARENTNOTIFY = 0x0210,
	WM_PASTE = 0x0302,
	WM_PENWINFIRST = 0x0380,
	WM_PENWINLAST = 0x038F,
	WM_POWER = 0x0048,
	WM_POWERBROADCAST = 0x0218,
	WM_PRINT = 0x0317,
	WM_PRINTCLIENT = 0x0318,
	WM_QUERYDRAGICON = 0x0037,
	WM_QUERYENDSESSION = 0x0011,
	WM_QUERYNEWPALETTE = 0x030F,
	WM_QUERYOPEN = 0x0013,
	WM_QUEUESYNC = 0x0023,
	WM_QUIT = 0x0012,
	WM_RBUTTONDBLCLK = 0x0206,
	WM_RBUTTONDOWN = 0x0204,
	WM_RBUTTONUP = 0x0205,
	WM_RENDERALLFORMATS = 0x0306,
	WM_RENDERFORMAT = 0x0305,
	WM_SETCURSOR = 0x0020,
	WM_SETFOCUS = 0x0007,
	WM_SETFONT = 0x0030,
	WM_SETHOTKEY = 0x0032,
	WM_SETICON = 0x0080,
	WM_SETREDRAW = 0x000B,
	WM_SETTEXT = 0x000C,
	WM_SETTINGCHANGE = 0x001A,
	WM_SHOWWINDOW = 0x0018,
	WM_SIZE = 0x0005,
	WM_SIZECLIPBOARD = 0x030B,
	WM_SIZING = 0x0214,
	WM_SPOOLERSTATUS = 0x002A,
	WM_STYLECHANGED = 0x007D,
	WM_STYLECHANGING = 0x007C,
	WM_SYNCPAINT = 0x0088,
	WM_SYSCHAR = 0x0106,
	WM_SYSCOLORCHANGE = 0x0015,
	WM_SYSCOMMAND = 0x0112,
	WM_SYSDEADCHAR = 0x0107,
	WM_SYSKEYDOWN = 0x0104,
	WM_SYSKEYUP = 0x0105,
	WM_TCARD = 0x0052,
	WM_TIMECHANGE = 0x001E,
	WM_TIMER = 0x0113,
	WM_UNDO = 0x0304,
	WM_UNINITMENUPOPUP = 0x0125,
	WM_USER = 0x0400,
	WM_USERCHANGED = 0x0054,
	WM_VKEYTOITEM = 0x002E,
	WM_VSCROLL = 0x0115,
	WM_VSCROLLCLIPBOARD = 0x030A,
	WM_WINDOWPOSCHANGED = 0x0047,
	WM_WINDOWPOSCHANGING = 0x0046,
	WM_WININICHANGE = 0x001A,
	WM_XBUTTONDBLCLK = 0x020D,
	WM_XBUTTONDOWN = 0x020B,
	WM_XBUTTONUP = 0x020C,
}

public enum TASKBARMESSAGE : int
{
	NIM_ADD = 0x00000000,
	NIM_MODIFY = 0x00000001,
	NIM_DELETE = 0x00000002,
	NIM_SETFOCUS = 0x00000003,
	NIM_SETVERSION = 0x00000004
}



================================================================================
FILE: :\DEV\sambar\Src\Tests\QueryPdb.cs
SIZE: 4.94 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;

public class QueryPdb
{
	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern bool SymInitialize(
		nint hProcess,
		string pdbPath,
		bool fInvadeProcess
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern uint SymSetOptions(
		uint SymOptions
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern ulong SymLoadModuleEx(
		nint hProcess,
		[Optional] nint hFile,
		string imageName,
		string moduleName,
		ulong baseOfDll,
		uint dllSize,
		nint data,
		uint flags
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern bool SymFromName(nint hProcess, [MarshalAs(UnmanagedType.LPTStr)] string symbolName, ref SYMBOL_INFO info);

	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern nint GetCurrentProcess();

	public delegate bool PsymEnumeratesymbolsCallback(ref SYMBOL_INFO info, uint symbolSize, [In, Optional] nint userContext);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern bool SymEnumSymbols(
		nint hProcess,
		ulong baseOfDll,
		string mask,
		PsymEnumeratesymbolsCallback callback,
		nint userContext
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern bool SymGetSearchPath(
		nint hProcess,
		StringBuilder SearchPath,
		uint SearchPathLength
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	public static extern bool SymGetSymbolFile(
		nint hProcess,
		string SymPath,
		string ImageFile,
		int Type,
		StringBuilder SymbolFile,
		int SymbolFileSize,
		StringBuilder DbgFile,
		int DbgFileSize
	);

	[DllImport("dbghelp.dll", SetLastError = true)]
	static extern bool SymSetSearchPath(IntPtr hProcess, string SearchPath);

	[DllImport("kernel32.dll", SetLastError = true)]
	public static extern nint LoadLibraryEx(string lpFileName, nint hFile, uint dwFlags);

	public static void Main()
	{
		string pdbFilePath = "Taskbar.pdb";
		long pdbFileSize = File.OpenRead(pdbFilePath).Length;
		nint hProcess = GetCurrentProcess();
		if (!SymInitialize(hProcess, pdbFilePath, false))
		{
			Console.WriteLine($"hProcess() failed: {Marshal.GetLastWin32Error()}");
			return;
		}
		uint dllBase = 0x10000000;
		SymLoadModuleEx(
			hProcess,
			0,
			pdbFilePath,
			null,
			(ulong)dllBase,
			(uint)pdbFileSize,
			0,
			0
		);

		// set mask to *GetWindow* or *CTaskListWnd* to resolve class methods
		SymEnumSymbols(hProcess, dllBase, "*CTaskListWnd*", (ref SYMBOL_INFO info, uint size, nint ctx) =>
		{
			Console.WriteLine($"[ NAME ]: {info.Name}, [ RVA ]: {info.Address - info.ModBase}");
			return true;
		}, 0);

		/// <summary>
		/// Taskbar.dll
		/// </summary>

		//string dllFile = "Taskbar.dll";
		//nint dllBase = LoadLibraryEx(dllFile, 0, 0x00000020);
		//nint hProcess = GetCurrentProcess();
		//if (!SymInitialize(hProcess, null, false))
		//{
		//	Console.WriteLine($"SymInitialize failed: 0x{Marshal.GetLastWin32Error():X}");
		//	return;
		//}
		//ulong symbolBase = SymLoadModuleEx(
		//	hProcess,
		//	IntPtr.Zero,
		//	dllFile,
		//	null,
		//	(ulong)dllBase,
		//	0,
		//	IntPtr.Zero,
		//	0
		//);

		//if (symbolBase == 0)
		//{
		//	Console.WriteLine($"SymLoadModuleEx failed: 0x{Marshal.GetLastWin32Error():X}");
		//	return;
		//}
		//SymEnumSymbols(hProcess, symbolBase, "*", (ref SYMBOL_INFO info, uint size, nint ctx) =>
		//{
		//	Console.WriteLine($"[SYMBOL] {info.Name}");
		//	return true;
		//}, IntPtr.Zero);
	}
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct SYMBOL_INFO
{
	public uint SizeOfStruct;
	public uint TypeIndex;
	public ulong Reserved0;
	private ulong Reserved1;
	public uint Index;
	public uint Size;
	public ulong ModBase;
	public uint Flags;
	public ulong Value;
	public ulong Address;
	public uint Register;
	public uint Scope;
	public uint Tag;
	public uint NameLen;
	public uint MaxNameLen;
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 2000)]
	public string Name;
	public static SYMBOL_INFO Default = new() { SizeOfStruct = (uint)Marshal.SizeOf(typeof(SYMBOL_INFO)), MaxNameLen = 2000 };
}

public enum SymTagEnum : ulong
{
	SymTagNull = 0,
	SymTagExe = 1,
	SymTagCompiland = 2,
	SymTagCompilandDetails = 3,
	SymTagCompilandEnv = 4,
	SymTagFunction = 5,
	SymTagBlock = 6,
	SymTagData = 7,
	SymTagAnnotation = 8,
	SymTagLabel = 9,
	SymTagPublicSymbol = 10,
	SymTagUDT = 11,
	SymTagEnum = 12,
	SymTagFunctionType = 13,
	SymTagPointerType = 14,
	SymTagArrayType = 15,
	SymTagBaseType = 16,
	SymTagTypedef = 17,
	SymTagBaseClass = 18,
	SymTagFriend = 19,
	SymTagFunctionArgType = 20,
	SymTagFuncDebugStart = 21,
	SymTagFuncDebugEnd = 22,
	SymTagUsingNamespace = 23,
	SymTagVTableShape = 24,
	SymTagVTable = 25,
	SymTagCustom = 26,
	SymTagThunk = 27,
	SymTagCustomType = 28,
	SymTagManagedType = 29,
	SymTagDimension = 30
}




================================================================================
FILE: :\DEV\sambar\Src\Tests\QueryPdb.runtimeconfig.json
SIZE: 0.26 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

{
  "runtimeOptions": {
    "tfm": "net9.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "9.0.0"
    },
    "configProperties": {
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}


================================================================================
FILE: :\DEV\sambar\Src\Tests\TaskbarWindows.cs
SIZE: 1.17 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System.Runtime.InteropServices;

public partial class Program
{
	const int GA_ROOTOWNER = 3;

	[DllImport("user32.dll", SetLastError = true)]
	extern static nint GetAncestor(
	  nint hwnd,
	  uint gaFlags
	);

	[DllImport("user32.dll", SetLastError = true)]
	extern static nint GetLastActivePopup(
		nint hWnd
	);

	[DllImport("user32.dll", SetLastError = true)]
	extern static bool IsWindowVisible(nint hWnd);

	// https://devblogs.microsoft.com/oldnewthing/20071008-00/?p=24863 
	public static bool IsWindowInTaskbar(nint hWnd)
	{
		// start at the owner window
		nint hWndWalk = GetAncestor(hWnd, GA_ROOTOWNER);

		nint hWndTry;
		// a window in taskbar / alt-tab is its own last popup window, so loop until hWnd walk becomes a popup window
		while ((hWndTry = GetLastActivePopup(hWndWalk)) != hWndWalk)
		{
			if (IsWindowVisible(hWndTry)) break;
			hWndWalk = hWndTry;
		}
		// once the walk is finished hWndWalk "is" the taskbarwindow in that owner chain, now check if the window you supplied is that window
		return hWnd == hWndWalk;
	}

	public static void Main()
	{
		Console.WriteLine("window in taskbar: " + IsWindowInTaskbar(0x270128));
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\.init.cs
SIZE: 0.06 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

// return the widget pack's name

return "Plain1";



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\.config.cs
SIZE: 0.47 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class BaseConfig : Config 
{
    public BaseConfig() 
    { 
        this.height = 30;
        this.width = 0;
        this.marginXLeft = 10;
        this.marginXRight = 10;
        this.marginYTop = 10;
        this.paddingXLeft = 0;
        this.paddingXRight = 0;
        this.paddingYTop = 0;
        this.paddingYDown = 0;
        this.backgroundColor = "#282828";
        this.borderColor = "#ffffff";
        this.borderThickness = 0;
    }
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\.layout.cs
SIZE: 2.91 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

class BaseLayout : Layout
{
	/// <summary>
	/// Create placeholder borders for each widget. These borders must be
	/// declared as fields of the Layout class and their names must match
	/// the name of their respective widget class
	/// </summary>

	Border Workspaces = new();
	Border Tray = new();
	Border NetworkManager = new();
	Border HideTaskbar = new();
	Border Clock = new();
	Border ScribblePad = new();
	Border StartButton = new();
	Border Counters = new();
	Border TaskbarApps = new();

	public BaseLayout()
	{
		/// <summary>
		/// Build the layout after choosing a layout type
		/// <summary>
		Grid grid = new();

		ColumnDefinition _col1 = new() { Width = new GridLength(1, GridUnitType.Star) };
		ColumnDefinition _col2 = new() { Width = new GridLength(1, GridUnitType.Auto) };
		ColumnDefinition _col3 = new() { Width = new GridLength(1, GridUnitType.Star) };

		grid.ColumnDefinitions.Add(_col1);
		grid.ColumnDefinitions.Add(_col2);
		grid.ColumnDefinitions.Add(_col3);

		StackPanel col1 = new();
		StackPanel col2 = new();
		StackPanel col3 = new();

		/// <summary>
		/// In WPF VerticalAlignment and HorizontalAlignment are
		/// properties of an objects that specifies how it aligns
		/// itself in its parent container. It is NOT about specifying
		/// to a container element how to align its children
		/// </summary>

		col1.Orientation = Orientation.Horizontal;
		col1.VerticalAlignment = VerticalAlignment.Center;

		col2.Orientation = Orientation.Horizontal;
		col2.HorizontalAlignment = HorizontalAlignment.Center;
		col2.VerticalAlignment = VerticalAlignment.Center;

		col3.Orientation = Orientation.Horizontal;
		col3.HorizontalAlignment = HorizontalAlignment.Right;
		col3.VerticalAlignment = VerticalAlignment.Center;
		col3.FlowDirection = FlowDirection.RightToLeft;
		col3.Margin = new(0, 0, 6, 0);

		Grid.SetColumn(col1, 0);
		Grid.SetColumn(col2, 1);
		Grid.SetColumn(col3, 2);

		// col1
		col1.Children.Add(Workspaces);
		TaskbarApps.Margin = new(5, 0, 0, 0);
		col1.Children.Add(TaskbarApps);
		// col2
		Clock.HorizontalAlignment = HorizontalAlignment.Center;
		col2.Children.Add(Clock);
		// col3
		List<Border> systemTray = new();
		systemTray.Add(StartButton);
		systemTray.Add(Counters);
		systemTray.Add(NetworkManager);
		systemTray.Add(Tray);
		//systemTray.Add(HideTaskbar);
		//systemTray.Add(ScribblePad);
		systemTray.ForEach(border =>
		{
			border.Margin = new(0, 0, 5, 0);
			border.VerticalAlignment = VerticalAlignment.Center;
			col3.Children.Add(border);
		});
		Counters.Margin = new(10, 0, 10, 0);

		/// <summary>
		/// Add all borders to the layout type [Grid || StackPanel]
		/// </summary>
		grid.Children.Add(col1);
		grid.Children.Add(col2);
		grid.Children.Add(col3);
		/// <summary>
		/// Set the finished layout type as the container
		/// <summary>
		//this.Container = panel;
		this.Container = grid;
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\.theme.cs
SIZE: 1.2 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

// GLOBAL RESOURCES USED BY YOUR THEME
// ALL VARIABLES MUST BE STATIC

// Fluent Icons
// https://fluenticons.co/
public class Theme
{
    public static Brush TEXT_COLOR = Utils.BrushFromHex("#EBDBB2");
    public static FontFamily FONT_FAMILY = new("JetBrains Mono");

    public static Brush BUTTON_FOREGROUND = new SolidColorBrush(Colors.White);
    public static Brush BUTTON_BACKGROUND = new SolidColorBrush(Colors.Transparent);
    public static Brush BUTTON_PRESSED_BACKGROUND = Utils.BrushFromHex("#575555");
    public static Brush BUTTON_BORDER_COLOR = new SolidColorBrush(Colors.Black);
    public static Brush BUTTON_HOVER_COLOR = Utils.BrushFromHex("#828181");
    public static CornerRadius BUTTON_CORNER_RADIUS = new(5);
    public static Thickness BUTTON_MARGIN = new(2);
    public static int ICON_WIDTH = 16;
    public static int ICON_HEIGHT= 16;
    public static int BUTTON_WIDTH = 20;
    public static int BUTTON_HEIGHT = 20;
    public static Thickness BUTTON_BORDER_THICKNESS = new(0);

    public static Brush WIDGET_BACKGROUND = new SolidColorBrush(Colors.Transparent);
    public static CornerRadius WIDGET_CORNER_RADIUS = new(5);
    public static int WIDGET_GAP = 5;
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\AudioInformation.widget.cs
SIZE: 0.99 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class AudioInformation : Widget
{
	public AudioInformation(WidgetEnv ENV) : base(ENV)
	{
		TextBlock textBlock = new();
		textBlock.Foreground = new SolidColorBrush(System.Windows.Media.Colors.Black);
		textBlock.FontFamily = Theme.FONT_FAMILY;
		textBlock.TextWrapping = TextWrapping.Wrap;
		textBlock.TextAlignment = TextAlignment.Right;
		//textBlock.FontWeight = FontWeights.Bold;

		Border border = new();
		//border.BorderBrush = new SolidColorBrush(Colors.Red);
		//border.BorderThickness = new(2);
		border.Child = textBlock;

		Window wnd = Sambar.api.CreateWidgetWindow(425, -210, 400, 50, centerOffset: true);
		wnd.Background = new SolidColorBrush(System.Windows.Media.Colors.Transparent);
		wnd.Content = border;
		wnd.Show();

		Sambar.api.MEDIA_INFO_EVENT += (MediaInfo info) =>
		{
			wnd.Dispatcher.Invoke(() => textBlock.Text = info.Title);
		};
		Sambar.api.MEDIA_STOPPED_EVENT += () =>
		{
			wnd.Dispatcher.Invoke(() => textBlock.Text = "");
		};
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\AudioVisualizer.widget.cs
SIZE: 1.06 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class AudioVisualizer : Widget
{
	public AudioVisualizer(WidgetEnv ENV) : base(ENV)
	{
		(ThreadWindow t_wnd, WpfPlot plt, FilledSignal signal) = Sambar.api.CreateAudioVisualizer(
			x: 530,
			y: -280,
			width: 200,
			height: 60,
			centerOffset: true,
			init: wnd =>
			{
				wnd.Background = new SolidColorBrush(Colors.Transparent);
			}
		);
		t_wnd.Run(() =>
		{
			StackPanel panel = new();
			Border pltBorder = new();

			signal.LineWidth = 2;
			signal.fillColor = System.Drawing.Color.Black;
			plt.Width = 200;
			plt.Height = 60;
			plt.Plot.Layout.Frameless();
			plt.Plot.FigureBackground = new() { Color = ScottColors.Transparent };
			plt.Plot.Axes.Color(ScottColors.Transparent);
			plt.Plot.Axes.FrameColor(ScottColors.Transparent);
			plt.Plot.Grid.LineColor = ScottColors.Transparent;

			//pltBorder.BorderBrush = new SolidColorBrush(Colors.Red);
			//pltBorder.BorderThickness = new(2);

			pltBorder.Child = plt;
			panel.Children.Add(pltBorder);

			t_wnd.wnd.Content = panel;
			t_wnd.wnd.Show();
		});
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\Clock.widget.cs
SIZE: 0.49 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class Clock : Widget
{
	TextBlock textBlock = new();

	public Clock(WidgetEnv ENV) : base(ENV)
	{
		textBlock.Foreground = Theme.TEXT_COLOR;
		textBlock.FontFamily = Theme.FONT_FAMILY;
		Sambar.api.CLOCK_TICKED += ClockTickedEventHandler;

		this.Content = textBlock;
	}

	public void ClockTickedEventHandler(Time time)
	{
		this.Thread.Invoke(() =>
		{
			textBlock.Text = $"{time.hours}:{time.minutes}:{time.seconds} {time.day}-{time.month}-{time.year}";
		});
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\Counters.widget.cs
SIZE: 1.51 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class Counters : Widget
{
	TextBlock textBlock = new();
	long cpuUsage = 0;
	float downSpeed = 0f, upSpeed = 0f;
	float memUsage = 0;
	public Counters(WidgetEnv ENV): base(ENV)
	{
		textBlock.Foreground = Theme.TEXT_COLOR;
		textBlock.FontFamily = Theme.FONT_FAMILY;

		Sambar.api.CPU_PERFORMANCE_NOTIFIED += (_usage) => { cpuUsage = _usage[0]; };
		Sambar.api.NETWORK_SPEED_NOTIFIED += (_speeds) => { downSpeed = _speeds[0]; upSpeed = _speeds[1]; };
		Sambar.api.MEMORY_USAGE_NOTIFIED += (_usage) => { memUsage = _usage[1] - _usage[0]; };
		UpdateText();

		this.Content = textBlock;
	}

	public void UpdateText()
	{
		Task.Run(async () =>
		{
			while (true)
			{
				(float _down, string _down_flag) = NormalizeSpeed(downSpeed);
				(float _up, string _up_flag) = NormalizeSpeed(upSpeed);

				// Dont add special characters such as '[' or ']' as these have special
				// meaning related to wpf databinding
				string text = $"NET: {_down:00.0} ↓{_down_flag} {_up:00.0} ↑{_up_flag}, MEM: {memUsage:00.00} Gb, CPU: {cpuUsage:00}%";
				this.Thread.Invoke(() => { textBlock.Text = text; });
				await Task.Delay(1000);
			}
		});
	}

	/// <summary>
	/// Normalize speed in Kbps to 00.0 format with appropriate flags
	/// </summary>
	public (float, string) NormalizeSpeed(float speed)
	{
		string unit = "Kb/s";
		if (speed > 100) unit = "Mb/s";
		if (speed > 100000) unit = "Gb/s";
		while (speed.ToString().Split(".")[0].Count() > 2) { speed /= 1024; }
		return (speed, unit);
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\HideTaskbar.widget.cs
SIZE: 0.61 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class HideTaskbar : Widget
{
	public HideTaskbar(WidgetEnv ENV) : base(ENV)
	{
		RoundedButton btn = new();
		btn.Height = Theme.BUTTON_HEIGHT;
		btn.Width = Theme.BUTTON_WIDTH;
		btn.Text = "H";
		btn.Foreground = Theme.TEXT_COLOR;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.FontFamily = Theme.FONT_FAMILY;
		btn.HoverEffect = true;
		btn.MouseDown += ButtonMouseDown;
		this.Content = btn;
	}
	public void ButtonMouseDown(object? sender, MouseEventArgs e)
	{
		Sambar.api.ToggleTaskbar();
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\NetworkManager.widget.cs
SIZE: 0.82 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class NetworkManager : Widget
{
	public NetworkManager(WidgetEnv ENV): base(ENV)
	{
		RoundedButton btn = new();
		//btn.Text = "W";
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.Margin = Theme.BUTTON_MARGIN;
		btn.Height = Theme.BUTTON_HEIGHT;
		btn.Width = Theme.BUTTON_WIDTH;
		btn.ImageSrc = Path.Join(ENV.ASSETS_FOLDER, "wifi.svg");
		btn.IconWidth = 16;
		btn.IconHeight = 16;
		btn.FontFamily = Theme.FONT_FAMILY;
		btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.HoverEffect = false;
		btn.MouseDown += ButtonMouseDown;
		this.Content = btn;
		this.Background = Theme.WIDGET_BACKGROUND;

	}

	public void ButtonMouseDown(object? sender, MouseEventArgs e)
	{
		Task.Run(() => { Sambar.api.LaunchUri("ms-actioncenter:controlcenter/"); });
	}
}




================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\ScribblePad.widget.cs
SIZE: 0.85 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class ScribblePad : Widget
{
	InkCanvas inkCanvas = new();
	RoundedButton btn = new();
	public ScribblePad(WidgetEnv ENV): base(ENV)
	{
		DrawingAttributes drawingAttributes = new();
		drawingAttributes.Color = Colors.White;
		inkCanvas.DefaultDrawingAttributes = drawingAttributes;

		btn.Height = Theme.BUTTON_HEIGHT;
		btn.Width = Theme.BUTTON_WIDTH;
		btn.Text = "S";
		btn.Foreground = Theme.TEXT_COLOR;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.FontFamily = Theme.FONT_FAMILY;
		btn.HoverEffect = true;
		btn.MouseDown += ButtonMouseDown;
		this.Content = btn;
	}

	public void ButtonMouseDown(object sender, MouseEventArgs e)
	{
		sambar.Menu menu = Sambar.api.CreateMenu(btn, 300, 300);
		menu.Content = inkCanvas;
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\StartButton.widget.cs
SIZE: 0.64 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System.IO;

public class StartButton : Widget
{
	public StartButton(WidgetEnv ENV): base(ENV)
	{
		RoundedButton btn = new();
		btn.Height = 16;
		btn.Width = 16;
		btn.Foreground = Theme.TEXT_COLOR;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.FontFamily = Theme.FONT_FAMILY;
		btn.HoverEffect = false;
		btn.ImageSrc = Path.Join(ENV.ASSETS_FOLDER, "start.svg"); 
		btn.MouseDown += ButtonMouseDown;
		this.Content = btn;
	}

	public void ButtonMouseDown(object sender, MouseEventArgs e)
	{
		Sambar.api.StartMenu();
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\TaskbarApps.widget.cs
SIZE: 2.11 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class TaskbarApps : Widget
{
	StackPanel panel = new();
	RunningApp focusedApp;
	List<RoundedButton> btns = new();

	public TaskbarApps(WidgetEnv ENV) : base(ENV)
	{
		panel.Orientation = Orientation.Horizontal;
		panel.VerticalAlignment = VerticalAlignment.Center;

		Sambar.api.TASKBAR_APPS_EVENT += UpdateTaskbarApps;
		Sambar.api.ACTIVE_WINDOW_CHANGED_EVENT += UpdateFocusedApp;
		this.Content = panel;
	}

	List<RunningApp> apps = new();
	public void UpdateTaskbarApps(List<RunningApp> apps)
	{
		Sambar.api.Print($"UpdateTaskbarApps fired!");
		this.Thread.Invoke(() =>
		{
			panel.Children.Clear();
			btns = new();
			foreach (var app in apps)
			{
				RoundedButton btn = new();
				btn.Id = app.hWnd.ToString();
				btn.Icon = app.icon;
				btn.Height = Sambar.api.config.height;
				btn.Width = Sambar.api.config.height;
				btn.IconHeight = Theme.BUTTON_HEIGHT;
				btn.IconWidth = Theme.BUTTON_WIDTH;
				btn.Margin = new(0, 0, 5, 0);
				btn.HoverEffect = false;
				List<MenuButton> menuItems = new()
				{
				   new("close")
				};
				menuItems.ForEach(item =>
				{
					item.MouseDown += (s, e) => app.Kill();
				});
				btn.MouseDown += (s, e) =>
				{
					switch (e.ChangedButton)
					{
						case MouseButton.Left:
							app.FocusWindow();
							break;
						case MouseButton.Right:
							Sambar.api.CreateContextMenu(menuItems);
							break;
					}

				};
				if (focusedApp?.hWnd == app.hWnd)
				{
					UpdateFocusedApp(app);
				}

				panel.Children.Add(btn);
				btns.Add(btn);
			}
		});
	}

	public void UpdateFocusedApp(RunningApp app)
	{
		focusedApp = app;
		this.Thread.Invoke(() =>
		{
			if (btns == null) return;
			foreach (var btn in btns)
			{
				if (btn.Id == app.hWnd.ToString())
				{
					btn.Background = Theme.BUTTON_PRESSED_BACKGROUND;
					btn.BorderBrush = Utils.BrushFromHex("#22F803");
					btn.BorderThickness = new(0, 5, 0, 0);
				}
				else
				{
					btn.Background = Theme.BUTTON_BACKGROUND;
					btn.BorderBrush = Theme.BUTTON_BORDER_COLOR;
					btn.BorderThickness = new(0);
				}
			}
		});
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\Tray.widget.cs
SIZE: 2.33 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

using System.IO;

public class Tray : Widget
{
	sambar.Menu? menu = null;
	public Tray(WidgetEnv ENV) : base(ENV)
	{
		//UpdateTrayPanel();

		RoundedButton btn = new();
		btn.ImageSrc = Path.Join(ENV.ASSETS_FOLDER, "arrow_down.svg");
		btn.IconHeight = Theme.ICON_HEIGHT;
		btn.IconWidth = Theme.ICON_WIDTH;
		btn.Height = Theme.BUTTON_HEIGHT;
		btn.Width = Theme.BUTTON_WIDTH;
		btn.Margin = Theme.BUTTON_MARGIN;
		btn.Foreground = Theme.TEXT_COLOR;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.HoverEffect = false;
		btn.MouseDown += (s, e) =>
		{
			menu = Sambar.api.CreateMenu(btn, 100, 100);
			UpdateTrayPanel();
		};

		this.Content = btn;
		this.Background = Theme.WIDGET_BACKGROUND;
		this.CornerRadius = Theme.WIDGET_CORNER_RADIUS;

		//Task.Run(async() =>
		//{
		//    Sambar.api.Print("STARTING TRAY LOOP");
		//    while(true)
		//    {
		//        UpdateTrayPanel();
		//        Sambar.api.Print("TRAY UPDATED");
		//        await Task.Delay(1000);
		//    }
		//});
		Sambar.api.TASKBAR_CHANGED += () => UpdateTrayPanel();
	}

	public void UpdateTrayPanel()
	{
		if (menu == null) return;
		menu.Dispatcher.Invoke(() =>
		{
			List<TrayIcon> trayIcons = Sambar.api.GetTrayIcons();
			WrapPanel panel = new();
			Sambar.api.Print($"UpdateTrayPanel(): {trayIcons.Count()}");
			panel.Orientation = Orientation.Horizontal;
			foreach (var trayIcon in trayIcons)
			{
				RoundedButton iconBtn = new();
				iconBtn.Height = Theme.BUTTON_HEIGHT;
				iconBtn.Width = Theme.BUTTON_WIDTH;
				iconBtn.Margin = Theme.BUTTON_MARGIN;
				iconBtn.Foreground = Theme.TEXT_COLOR;
				iconBtn.Background = Theme.BUTTON_BACKGROUND;
				iconBtn.HoverColor = Theme.BUTTON_HOVER_COLOR;
				iconBtn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
				iconBtn.FontFamily = Theme.FONT_FAMILY;
				iconBtn.Icon = trayIcon.icon;
				iconBtn.HoverEffect = false;
				iconBtn.Margin = new(10, 10, 0, 0);
				iconBtn.MouseDown += (s, e) =>
				{
					switch (e.ChangedButton)
					{
						case MouseButton.Right:
							trayIcon.ContextMenu();
							break;
						case MouseButton.Left:
							trayIcon.Click();
							break;
					}
				};
				panel.Children.Add(iconBtn);
			}
			menu.Content = panel;
		});
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\Wallpapers.widget.cs
SIZE: 3.86 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class Wallpapers : Widget
{
	public Wallpapers(WidgetEnv ENV) : base(ENV)
	{
		RoundedButton btn = new();
		btn.Height = Theme.BUTTON_HEIGHT;
		btn.Width = Theme.BUTTON_WIDTH;
		btn.Margin = Theme.BUTTON_MARGIN;
		btn.ImageSrc = Path.Join(ENV.ASSETS_FOLDER, "image.svg");
		btn.IconWidth = 13;
		btn.IconHeight = 13;
		btn.Background = Theme.BUTTON_BACKGROUND;
		btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
		btn.MouseDown += ButtonMouseDown;
		this.Content = btn;
	}
	public void ButtonMouseDown(object? sender, MouseEventArgs e)
	{
		sambar.Menu menu = Sambar.api.CreateMenu(0, 0, 500, 300, centerOffset: true);

		string wallpapersFolder = Path.Join(ENV.HOME, "Pictures", "Wallpapers");
		string[] walls = Directory.GetFiles(wallpapersFolder).Where(path => path.EndsWith(".jpg") || path.EndsWith(".png") || path.EndsWith(".jpeg")).ToArray();

		ImageSelector imageSelector = new();
		Task.Run(() =>
			this.Thread.Invoke(() =>
				imageSelector.Load(walls)
			)
		);
		imageSelector.IMAGE_SELECTED += (imgFile) => Sambar.api.SetWallpaper(imgFile, WallpaperAnimation.NONE);
		//imageSelector.IMAGE_SELECTED += (imgFile) => Sambar.api.SetWallpaper(imgFile);

		menu.KeyDown += (s, e) => { if (e.Key == Key.Escape) menu.Close(); };
		menu.Content = imageSelector;
	}
}

public class ImageSelector : Grid
{
	Image img1 = new();
	Image img2 = new();
	Image img3 = new();

	Border border1 = new() { Padding = new(10) };
	Border border2 = new() { Padding = new(10), BorderBrush = new SolidColorBrush(Colors.Green), BorderThickness = new(2), VerticalAlignment = VerticalAlignment.Center, CornerRadius = new(5) };
	Border border3 = new() { Padding = new(10) };

	string[] imgFiles = [];
	int index = 0;
	public delegate void ImageSelectedHandler(string imgFile);
	public event ImageSelectedHandler IMAGE_SELECTED = (imgFile) => { };
	public ImageSelector()
	{
		ColumnDefinition col1 = new() { Width = new GridLength(1, GridUnitType.Star) };
		ColumnDefinition col2 = new() { Width = new GridLength(1.5, GridUnitType.Star) };
		ColumnDefinition col3 = new() { Width = new GridLength(1, GridUnitType.Star) };

		this.ColumnDefinitions.Add(col1);
		this.ColumnDefinitions.Add(col2);
		this.ColumnDefinitions.Add(col3);

		border1.Child = img1;
		border2.Child = img2;
		border3.Child = img3;

		this.Children.Add(border1);
		this.Children.Add(border2);
		this.Children.Add(border3);

		Grid.SetColumn(border1, 0);
		Grid.SetColumn(border2, 1);
		Grid.SetColumn(border3, 2);

		this.Focusable = true;
		this.Loaded += (s, e) =>
		{
			this.Focus();
		};

		this.KeyDown += (s, e) =>
		{
			switch (e.Key)
			{
				case Key.L or Key.Right:
					Forward();
					break;
				case Key.H or Key.Left:
					Backward();
					break;
				case Key.Enter:
					IMAGE_SELECTED(this.imgFiles[index]);
					break;
			}
			Sambar.api.Print($"key pressed: {e.Key.ToString()}, index: {index}");
		};
	}

	public ImageSelector(string[] imgFiles)
	{
		Load(imgFiles);
	}

	public void Load(string[] imgFiles)
	{
		this.imgFiles = imgFiles;
		SetState(index);
	}

	public void Forward()
	{
		if (index == this.imgFiles.Length - 1) return;
		index++;
		SetState(index);
	}
	public void Backward()
	{
		if (index == 0) return;
		index--;
		SetState(index);
	}

	public void SetState(int i)
	{
		if (index == 0)
		{
			img1.Source = null;
			SetImageSource(img2, imgFiles[i]);
			SetImageSource(img3, imgFiles[i + 1]);
		}
		else if (index == imgFiles.Length - 1)
		{
			SetImageSource(img2, imgFiles[i]);
			SetImageSource(img3, imgFiles[i + 1]);
			img3.Source = null;
		}
		else
		{
			SetImageSource(img1, imgFiles[i - 1]);
			SetImageSource(img2, imgFiles[i]);
			SetImageSource(img3, imgFiles[i + 1]);
		}
	}

	public void SetImageSource(Image img, string imgFile)
	{
		img.Source = Sambar.api.GetImageSource(imgFile);
	}
}




================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Base\Workspaces.widget.cs
SIZE: 2.32 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class Workspaces : Widget
{
	List<Workspace> workspaces = new();
	List<RoundedButton> buttons = new();
	public Workspaces(WidgetEnv ENV) : base(ENV)
	{
		workspaces = Sambar.api.workspaces;

		//this.CornerRadius = Theme.WIDGET_CORNER_RADIUS;
		StackPanelWithGaps panel = new(Theme.WIDGET_GAP, workspaces.Count);
		panel.Orientation = Orientation.Horizontal;
		panel.VerticalAlignment = VerticalAlignment.Center;
		panel.ClipToBounds = true;
		for (int i = 1; i <= workspaces.Count; i++)
		{
			RoundedButton btn = new();
			btn.Text = $"{i}";
			btn.FontFamily = Theme.FONT_FAMILY;
			btn.CornerRadius = Theme.BUTTON_CORNER_RADIUS;
			btn.Width = Theme.BUTTON_WIDTH;
			btn.Height = Theme.BUTTON_HEIGHT;
			btn.BorderThickness = Theme.BUTTON_BORDER_THICKNESS;
			btn.BorderBrush = Theme.BUTTON_BORDER_COLOR;
			btn.Foreground = Theme.TEXT_COLOR;
			btn.HoverColor = Theme.BUTTON_HOVER_COLOR;
			btn.Background = Theme.BUTTON_BACKGROUND;
			btn.HoverEffect = true;
			btn.MouseDown += WorkspaceButtonClicked;
			buttons.Add(btn);
			panel.Add(btn);
		}
		Sambar.api.Print($"workspaces: {workspaces.Count}, buttons: {buttons.Count}, index: {Sambar.api.currentWorkspace.index}");
		if (buttons.Count > 0)
			buttons[Sambar.api.currentWorkspace.index].Background = Theme.BUTTON_PRESSED_BACKGROUND;
		Sambar.api.GLAZE_WORKSPACE_CHANGED += (workspace) =>
		{
			RedrawButtons(workspace.index);
		};
		this.Content = panel;
	}

	public void RedrawButtons(int index)
	{
		this.Thread.Invoke(() =>
		{
			foreach (var button in buttons)
			{
				button.Background = Theme.BUTTON_BACKGROUND;
			}
			buttons[index].Background = Theme.BUTTON_PRESSED_BACKGROUND;
			buttons[index].HoverEffect = false;
		});
	}

	// for updating Glaze when buttons pressed
	bool buttonRedrawing = false;
	public void WorkspaceButtonClicked(object? sender, RoutedEventArgs e)
	{
		buttonRedrawing = true;
		var btn = sender as RoundedButton;
		string clickedBtnName = Convert.ToString(btn.Text);
		Workspace clickedWorkspace = workspaces.Where(wksp => wksp.name == clickedBtnName).First();
		int clickedBtnIndex = clickedWorkspace.index;
		RedrawButtons(clickedBtnIndex);
		Task.Run(async () =>
		{
			await Sambar.api.ChangeWorkspace(clickedWorkspace);
			await Task.Delay(3000);
			buttonRedrawing = false;
		});
	}
}




================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Plain1\.config.cs
SIZE: 0.41 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

public class BaseConfig : Config
{
	public BaseConfig()
	{
		this.height = 20;
		this.width = 0;
		this.marginXLeft = 0;
		this.marginXRight = 0;
		this.marginYTop = 0;
		this.paddingXLeft = 0;
		this.paddingXRight = 0;
		this.paddingYTop = 0;
		this.paddingYDown = 0;
		this.backgroundColor = "#1a1a1a";
		this.borderColor = "#ffffff";
		this.borderThickness = 0;
		this.roundedCorners = false;
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Plain1\.imports.cs
SIZE: 0.2 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

return new WidgetImports
{
	importsPack = "Base",
	widgets = ["Clock", "Tray", "Counters", "TaskbarApps", "AudioVisualizer", "AudioInformation", "Workspaces", "NetworkManager", "Wallpapers"]
};



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Plain1\.layout.cs
SIZE: 2.97 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

class BaseLayout : Layout
{
	/// <summary>
	/// Create placeholder borders for each widget. These borders must be
	/// declared as fields of the Layout class and their names must match
	/// the name of their respective widget class
	/// </summary>

	Border Workspaces = new();
	Border Tray = new();
	Border NetworkManager = new();
	Border HideTaskbar = new();
	Border Clock = new();
	Border ScribblePad = new();
	Border StartButton = new();
	Border Counters = new();
	Border TaskbarApps = new();
	Border Wallpapers = new();

	public BaseLayout()
	{
		/// <summary>
		/// Build the layout after choosing a layout type
		/// <summary>
		Grid grid = new();

		ColumnDefinition _col1 = new() { Width = new GridLength(1, GridUnitType.Star) };
		ColumnDefinition _col2 = new() { Width = new GridLength(1, GridUnitType.Auto) };
		ColumnDefinition _col3 = new() { Width = new GridLength(1, GridUnitType.Star) };

		grid.ColumnDefinitions.Add(_col1);
		grid.ColumnDefinitions.Add(_col2);
		grid.ColumnDefinitions.Add(_col3);

		StackPanel col1 = new();
		StackPanel col2 = new();
		StackPanel col3 = new();

		/// <summary>
		/// In WPF VerticalAlignment and HorizontalAlignment are
		/// properties of an objects that specifies how it aligns
		/// itself in its parent container. It is NOT about specifying
		/// to a container element how to align its children
		/// </summary>

		col1.Orientation = Orientation.Horizontal;
		col1.VerticalAlignment = VerticalAlignment.Center;

		col2.Orientation = Orientation.Horizontal;
		col2.HorizontalAlignment = HorizontalAlignment.Center;
		col2.VerticalAlignment = VerticalAlignment.Center;

		col3.Orientation = Orientation.Horizontal;
		col3.HorizontalAlignment = HorizontalAlignment.Right;
		col3.VerticalAlignment = VerticalAlignment.Center;
		col3.FlowDirection = FlowDirection.RightToLeft;
		col3.Margin = new(0, 0, 6, 0);

		Grid.SetColumn(col1, 0);
		Grid.SetColumn(col2, 1);
		Grid.SetColumn(col3, 2);

		// col1
		col1.Children.Add(Workspaces);
		TaskbarApps.Margin = new(5, 0, 0, 0);
		col1.Children.Add(TaskbarApps);
		// col2
		Clock.HorizontalAlignment = HorizontalAlignment.Center;
		col2.Children.Add(Clock);
		// col3
		List<Border> systemTray = new();
		systemTray.Add(StartButton);
		systemTray.Add(Counters);
		systemTray.Add(NetworkManager);
		systemTray.Add(Tray);
		systemTray.Add(Wallpapers);
		//systemTray.Add(HideTaskbar);
		//systemTray.Add(ScribblePad);
		systemTray.ForEach(border =>
		{
			border.Margin = new(0, 0, 5, 0);
			border.VerticalAlignment = VerticalAlignment.Center;
			col3.Children.Add(border);
		});
		Counters.Margin = new(10, 0, 10, 0);

		/// <summary>
		/// Add all borders to the layout type [Grid || StackPanel]
		/// </summary>
		grid.Children.Add(col1);
		grid.Children.Add(col2);
		grid.Children.Add(col3);
		/// <summary>
		/// Set the finished layout type as the container
		/// <summary>
		//this.Container = panel;
		this.Container = grid;
	}
}



================================================================================
FILE: :\DEV\sambar\Src\WidgetPacks\Plain1\.theme.cs
SIZE: 1.2 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

// GLOBAL RESOURCES USED BY YOUR THEME
// ALL VARIABLES MUST BE STATIC

// Fluent Icons
// https://fluenticons.co/
public class Theme
{
    public static Brush TEXT_COLOR = Utils.BrushFromHex("#EBDBB2");
    public static FontFamily FONT_FAMILY = new("JetBrains Mono");

    public static Brush BUTTON_FOREGROUND = new SolidColorBrush(Colors.White);
    public static Brush BUTTON_BACKGROUND = new SolidColorBrush(Colors.Transparent);
    public static Brush BUTTON_PRESSED_BACKGROUND = Utils.BrushFromHex("#575555");
    public static Brush BUTTON_BORDER_COLOR = new SolidColorBrush(Colors.Black);
    public static Brush BUTTON_HOVER_COLOR = Utils.BrushFromHex("#828181");
    public static CornerRadius BUTTON_CORNER_RADIUS = new(0);
    public static Thickness BUTTON_MARGIN = new(0);
    public static int ICON_WIDTH = 14;
    public static int ICON_HEIGHT= 14;    
    public static int BUTTON_WIDTH = 20;
    public static int BUTTON_HEIGHT = 20;
    public static Thickness BUTTON_BORDER_THICKNESS = new(0);

    public static Brush WIDGET_BACKGROUND = new SolidColorBrush(Colors.Transparent);
    public static CornerRadius WIDGET_CORNER_RADIUS = new(5);
    public static int WIDGET_GAP = 5;
}



================================================================================
FILE: :\DEV\sambar\Todo\Bugs.md
SIZE: 0.23 KB
MODIFIED: 09/25/2025 13:32:59
================================================================================

 - right clicking taskbar items sometimes crashes the app
 - audio visualizer showing garbage during low volume parts of a track
 - action center stuck after launch and requires focus to disappear
 - discord sometimes crashes the app



===============================================================================
EXPORT COMPLETED: 09/25/2025 15:08:20
Total Files Exported: 79
Output File: .\Docs\project_export.txt
===============================================================================
